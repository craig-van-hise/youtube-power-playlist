<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powerlist</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: { "primary": "#137fec", "bg-dark": "#101922", "surface": "#192633", "border": "#233648", "text-sub": "#92adc9" },
                    fontFamily: { sans: ["Inter", "sans-serif"] }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #111a22; }
        ::-webkit-scrollbar-thumb { background: #233648; border-radius: 4px; }
        
        body { overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        /* Flex Container Safety */
        /* --- LAYOUT & LAYERING --- */
        #left-panel, #player-panel, #video-stage {
            position: relative;
            background-color: #101922 !important; /* Solid background */
            box-sizing: border-box;
        }

        #left-panel { z-index: 10; border-right: 1px solid #233648; }
        #player-panel { z-index: 20; display: flex; flex-direction: column; min-width: 0; }

        /* The Safety Shield (Invisible until dragging) */
        #iframe-shield {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999;
            display: none; /* Hidden by default */
        }

        /* --- SPLITTERS --- */
        #splitter-vertical {
            width: 12px;
            background: #0d1218;
            border-left: 1px solid #233648;
            border-right: 1px solid #233648;
            cursor: col-resize;
            z-index: 50; /* Above everything */
            flex-shrink: 0;
            display: none; /* Default hidden (Jukebox mode) */
        }
        #splitter-vertical:hover { background: #137fec; }

        #splitter-horizontal {
            height: 12px;
            background: #0d1218;
            border-top: 1px solid #233648;
            border-bottom: 1px solid #233648;
            cursor: row-resize;
            z-index: 50; /* Above everything */
            width: 100%;
            display: block !important; /* Force Visibility */
            flex-shrink: 0;
        }
        #splitter-horizontal:hover { background: #137fec; }

        /* Show based on mode */
        .mode-study #splitter-vertical { display: block; }
        .mode-jukebox #splitter-horizontal { display: block; }

        /* Jukebox Mode */
        /* Jukebox Mode */
        .mode-jukebox { display: flex !important; flex-direction: column !important; }
        /* FORCE FLEXBOX LAYOUT */
        #app-container.mode-study {
            display: flex !important;
            flex-direction: row !important;
            width: 100vw !important;
            height: 100vh !important;
            overflow: hidden !important;
        }

        /* SIDEBAR: STRICT LIMITS */
        .mode-study #left-panel {
            width: 350px; /* Default start */
            min-width: 250px !important; /* Minimum safety only */
            /* max-width removed to allow making video smaller */
            flex-shrink: 0 !important;
            border-right: 1px solid #233648;
            z-index: 10;
            position: relative;
            background-color: #101922 !important;
        }

        /* PLAYER: FILL REMAINING SPACE */
        .mode-study #player-panel {
            flex-grow: 1 !important;
            flex-shrink: 1 !important;
            min-width: 0 !important; /* CRITICAL FIX for Flexbox overflow */
            width: auto !important;
            display: flex;
            flex-direction: column;
        }

        /* JUKEBOX OVERRIDES */
        .mode-jukebox #left-panel {
            width: 100% !important;
            flex: 1 !important; /* Take available space */
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allow shrinking */
            overflow: hidden; /* CRITICAL: Prevent panel itself from scrolling */
        }

        .mode-jukebox #player-panel {
            min-height: 80px !important;
            height: 80px !important;
            border-top: 1px solid #233648;
            background: #101922;
            z-index: 50;
            flex-shrink: 0 !important;
            display: flex !important;
        }

        .mode-jukebox .table-container {
            flex-grow: 1 !important;
            height: 100%; /* Ensure it fills parent */
            overflow-y: auto !important; /* Force scroll */
        }

        .mode-jukebox .study-only { display: none !important; }
        .mode-jukebox .jukebox-only { display: flex !important; }
        .mode-jukebox .col-compact-hide { display: table-cell; } /* Show all cols in Jukebox */

        .mode-study .study-only { display: flex !important; }
        .mode-study .jukebox-only { display: none !important; }
        .mode-study .col-compact-hide { display: none; } /* Hide details in Sidebar */

        /* Row States */
        .row-selected { background-color: #233648; } 
        .row-active { background-color: rgba(19, 127, 236, 0.15) !important; border-left: 3px solid #137fec; } 
        
        /* Volume Slider */
        .vol-container:hover .vol-slider { display: block; }
        .vol-slider { display: none; width: 80px; margin-left: 10px; accent-color: #137fec; }

        /* Tags */
        .tag-pill { background: #233648; color: #92adc9; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-right: 4px; display: inline-block; border: 1px solid #233648; white-space: nowrap; }

        /* Modal */
        dialog::backdrop { background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(2px); }
        .input-dark { 
            width: 100%; 
            background: #101922 !important; /* Override Tailwind Forms white bg */
            border: 1px solid #233648; 
            border-radius: 4px; 
            padding: 8px; 
            margin-bottom: 16px; 
            color: white !important; 
            font-size: 14px; 
            outline: none; 
        }
        .input-dark:focus { border-color: #137fec; }
        .input-disabled { background: #192633; color: #92adc9; cursor: not-allowed; }
        
        /* Sorting Indicators */
        th.sortable { cursor: pointer; user-select: none; }
        th.sortable:hover { color: white; }
        th.sort-asc::after { content: ' ▲'; font-size: 0.8em; }
        th.sort-desc::after { content: ' ▼'; font-size: 0.8em; }
        
        /* Drag and Drop */
        tr.opacity-50 {
            opacity: 0.5;
            background-color: rgba(19, 127, 236, 0.2) !important; 
        }
        tr.drag-over {
            border-top: 2px solid #137fec !important; 
        }

        /* Force Solid Backgrounds to stop bleed-through */

        
        /* The "Safety Shield" - Invisible by default */
        #iframe-shield {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999; /* Super high to catch all clicks */
            display: none; /* Hidden normally */
        }
        
        /* Splitters */


        /* Show based on mode */
        .mode-study #splitter-vertical { display: block; }
        .mode-jukebox #splitter-horizontal { display: block; }

        /* --- POWER USER GRID --- */
        #table-toolbar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; background: #192633; border-bottom: 1px solid #233648;
        }
        .table-container { overflow-x: auto; width: 100%; }
        
        /* Grid Borders & Layout */
        table { border-collapse: separate; border-spacing: 0; min-width: 100%; }
        th, td { 
            border-right: 1px solid #233648; 
            border-bottom: 1px solid #233648; /* Row lines too */
            padding: 8px 12px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            vertical-align: middle;
        }
        th:last-child, td:last-child { border-right: none; }
        
        .star-rating { color: #fbbf24; letter-spacing: 2px; }
        
        /* Resizable Header Base */
        .resizable-col { position: relative; }
        
        /* Column Resizer Grip */
        /* Column Resizer Grip */
        .col-resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            background: transparent;
            z-index: 10;
        }
        .col-resizer:hover { background: #137fec; }

        /* --- FIXED WIDTHS (PRP #20) --- */
        /* All columns must have fixed widths to prevent squishing in fixed-layout table */
        .col-index { width: 50px; }
        .col-watched { width: 50px; }
        .col-thumbnail { width: 130px; } /* Increased for safety */
        .col-original_date, .col-published_at { width: 110px; font-family: monospace; }
        .col-rating { width: 140px; } /* Increased for safety */
        .col-duration { width: 70px; text-align: right; font-family: monospace; }
        
        /* Dynamic Columns - Fixed Layout Needs Explicit Widths */
        .col-title { width: 350px; }
        .col-channel { width: 200px; }
        .col-tldr { width: 100px; }
        .col-desc { width: 200px; }
        .col-tags { width: 150px; }
        .col-tags { width: 150px; }
        .col-notes { width: 80px; } /* Increased from 60px and made resizable */

        /* --- TABLE CARD (New Wrapper) --- */
        #table-card {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Jukebox Mode: Card Style */
        .mode-jukebox #table-card {
            margin: 24px 50px;
            border: 1px solid #233648;
            border-radius: 12px;
            background-color: #101922; /* Ensure background behind table */
        }
        
        /* Study Mode: Full Bleed (Sidebar) */
        .mode-study #table-card {
            margin: 0;
            border: none;
            border-radius: 0;
        }
        /* Tag Pills (Interactive) */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            background: #1e2a38;
            color: #8b9bb4;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 2px;
            border: 1px solid #233648;
        }
        .tag-remove {
            margin-left: 5px;
            cursor: pointer;
            color: #ff4d4d;
            font-weight: bold;
        }
        .tag-remove:hover { color: #ff0000; }
        
        .tag-add {
            cursor: pointer;
            color: #137fec;
            font-size: 14px;
            margin-left: 4px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }
        .tag-add:hover { color: #3b82f6; }
    </style>
</head>
<body class="bg-bg-dark text-white font-sans">

    <header class="h-16 flex items-center justify-between px-6 bg-surface border-b border-border shrink-0 z-20">
        <div class="flex items-center gap-3">
            <div class="size-8 rounded bg-primary/20 text-primary flex items-center justify-center">
                <span class="material-symbols-rounded">play_circle</span>
            </div>
            <h1 class="font-bold text-lg hidden md:block tracking-tight">Powerlist</h1>
        </div>
        <div class="flex bg-bg-dark rounded-lg p-1 border border-border">
            <button onclick="setMode('jukebox')" id="btn-jukebox" class="px-4 py-1.5 rounded-md text-sm font-medium text-white bg-primary shadow">Jukebox</button>
            <button onclick="setMode('study')" id="btn-study" class="px-4 py-1.5 rounded-md text-sm font-medium text-text-sub hover:text-white">Study Mode</button>
        </div>
        <div class="flex items-center gap-4">
            <button onclick="window.openPlaylistModal ? window.openPlaylistModal() : alert('System Loading...')" class="bg-surface hover:bg-white/10 border border-border px-3 py-1.5 rounded-lg flex items-center gap-2 text-sm font-medium transition-colors">
                <span class="material-symbols-rounded text-primary">folder_open</span> 
                <span id="current-playlist-name">Playlists</span>
            </button>
            <button onclick="window.enrichCloudPlaylist()" class="bg-surface hover:bg-white/10 border border-border px-3 py-1.5 rounded-lg flex items-center gap-2 text-sm font-medium transition-colors" title="AI Enrich Playlist">
                <span class="material-symbols-rounded text-purple-400">auto_awesome</span> 
                <span class="hidden md:inline">Enrich</span>
            </button>
            <div class="flex items-center gap-3" id="user-profile-container">
            <!-- Auth State Loading Skeleton -->
            <div class="size-9 rounded-full bg-surface border border-border animate-pulse"></div>
        </div>
    </header>

    <div id="app-container" class="mode-jukebox flex-1 overflow-hidden">
        <div id="left-panel" class="bg-bg-dark" tabindex="0">
            <div class="jukebox-only p-4 flex justify-between items-center">
                <h2 class="text-xl font-bold">All Videos</h2>
                <div class="flex gap-2">
                    <button onclick="document.getElementById('powerSearchModal').showModal()" class="text-primary hover:text-white px-3 py-2 rounded text-sm font-medium flex items-center gap-2 border border-primary/30 hover:bg-primary/10">
                        <span class="material-symbols-rounded text-sm">bolt</span> Power Search
                    </button>
                    <button onclick="openAddModal()" class="bg-primary hover:bg-blue-600 px-4 py-2 rounded text-sm font-medium flex items-center gap-2">
                        <span class="material-symbols-rounded text-sm">add</span> Add Video
                    </button>
                </div>
            </div>
            <!-- Table Card Wrapper -->
            <div id="table-card">
                <div id="table-toolbar" class="jukebox-only flex items-center gap-2">
                    <input type="text" id="table-search" placeholder="Search library..." oninput="searchTerm = this.value.toLowerCase(); renderTable();" class="bg-bg-dark border border-border rounded px-3 py-1.5 text-sm w-64 focus:border-primary outline-none">
                    <button id="btn-cols" class="text-sm text-text-sub hover:text-white flex items-center gap-1">
                        <span class="material-symbols-rounded text-base">view_column</span> Columns
                    </button>
                    <div class="h-4 border-l border-border mx-2"></div>
                    <button onclick="clearWatched()" class="text-sm text-text-sub hover:text-red-400 flex items-center gap-1" title="Archive watched videos to history">
                        <span class="material-symbols-rounded text-base">auto_delete</span> Clear Watched
                    </button>
                </div>
    
                <div class="table-container flex-1 overflow-auto bg-bg-dark">
                    <table class="table-fixed min-w-full text-left border-collapse" style="width: max-content; min-width: 100%;">
                        <thead id="tableHead" class="bg-surface sticky top-0 z-20 text-xs uppercase text-text-sub font-semibold tracking-wider shadow-sm">
                            <!-- Headers generated by JS -->
                        </thead>
                        <tbody id="tableBody" class="divide-y divide-border/50 text-sm text-text-sub"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Vertical Splitter (between Left Panel and Player Panel) -->
        <div id="splitter-vertical" class="splitter"></div>
        <!-- Horizontal Splitter (Moved inside player panel) -->

        <div id="player-panel">


            <div id="video-stage" style="display:none; width: 100%; height: 60%; min-height: 200px; background: black;">
                 <div id="yt-player" style="width: 100%; height: 100%;"></div>
                 <div id="iframe-shield"></div>
            </div>
            
            <div id="splitter-horizontal" class="splitter"></div>

            <div class="study-only p-4 border-b border-border bg-surface flex justify-between items-center">
                <div>
                    <h2 id="study-title" class="text-white font-bold text-lg truncate max-w-md">Select a Video</h2>
                    <div class="text-xs text-text-sub mt-1">Now Playing</div>
                </div>
                <div class="flex gap-2">
                     <button onclick="insertTimestamp()" class="bg-border hover:bg-white/10 text-white px-3 py-1.5 rounded text-xs font-bold flex gap-1 items-center">
                        <span class="material-symbols-rounded text-sm">schedule</span> Timestamp
                     </button>
                </div>
            </div>

            <div class="study-only flex-1 flex flex-col p-6 bg-bg-dark min-h-0">
                <div class="flex flex-col h-full bg-surface rounded-xl border border-border overflow-hidden">
                    <div class="flex items-center justify-between px-4 py-2 border-b border-border bg-[#1e2d3d]">
                        <span class="text-xs font-bold uppercase tracking-wider text-white">My Notes</span>
                        <button onclick="saveNotes()" class="text-xs text-primary hover:text-white">Save</button>
                    </div>
                    <textarea id="notes-area" class="flex-1 w-full bg-transparent p-4 text-gray-200 resize-none outline-none font-mono text-sm leading-relaxed" placeholder="Type notes here..."></textarea>
                </div>
            </div>

            <div class="jukebox-only w-full h-full items-center justify-between px-4 gap-4">
                <!-- Transport Scrubber (PRP #21) -->
                <div id="transport-bar" class="flex items-center gap-3 bg-bg-dark border border-border p-2 rounded-lg flex-1 mr-4">
                    <button id="btn-transport-play" onclick="togglePlay()" class="bg-primary/20 hover:bg-primary text-primary hover:text-white rounded-full p-1 transition-colors">
                        <span class="material-symbols-rounded text-lg">play_arrow</span>
                    </button>
                    
                    <span id="time-current" class="font-mono text-xs text-text-sub w-10 text-right">0:00</span>
                    
                    <input type="range" id="scrubber" min="0" value="0" step="1" 
                           class="flex-1 cursor-pointer accent-primary h-1 bg-border rounded-full appearance-none hover:h-2 transition-all">
                    
                    <span id="time-total" class="font-mono text-xs text-text-sub w-10">0:00</span>
                </div>

                <div class="flex items-center gap-3 w-1/6 min-w-[200px]">
                    <div class="flex flex-col truncate">
                        <span id="footer-title" class="text-white font-bold text-sm truncate">Select a Video</span>
                        <span class="text-xs text-primary">Powerlist Player</span>
                    </div>
                </div>
                
                <div class="flex items-center gap-6 justify-center">
                    <button onclick="playPrev()" class="text-text-sub hover:text-white"><span class="material-symbols-rounded text-2xl">skip_previous</span></button>
                    <button onclick="togglePlay()" class="bg-primary text-white rounded-full p-2 hover:scale-105 shadow-lg shadow-primary/30">
                        <span id="play-icon" class="material-symbols-rounded text-2xl">play_arrow</span>
                    </button>
                    <button onclick="playNext()" class="text-text-sub hover:text-white"><span class="material-symbols-rounded text-2xl">skip_next</span></button>
                </div>

                <div class="w-1/6 flex justify-end items-center vol-container">
                    <span class="material-symbols-rounded text-text-sub">volume_up</span>
                    <input type="range" id="vol-slider" min="0" max="100" value="80" class="vol-slider" oninput="setVolume(this.value)">
                </div>
            </div>
        </div> 
    </div>

    <dialog id="addModal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-96">
        <h3 class="text-lg font-bold mb-4">Add YouTube Video</h3>
        <input type="text" id="newUrl" oninput="debounceFetch()" placeholder="Paste YouTube URL..." class="input-dark text-white placeholder-gray-500">
        <input type="text" id="newTitle" placeholder="Video Title" class="input-dark text-white placeholder-gray-500">
        <input type="text" id="newChannel" placeholder="Channel Name" class="input-dark input-disabled text-white placeholder-gray-500" readonly>
        
        <label class="text-xs text-text-sub uppercase font-bold tracking-wider mb-1 block">Tags (comma separated)</label>
        <input type="text" id="newTags" placeholder="e.g. Jazz, Study, Drum Solo" class="input-dark text-white placeholder-gray-500">

        <div class="flex justify-end gap-2 mt-4">
            <button onclick="closeAddModal()" class="px-4 py-2 text-sm text-text-sub hover:text-white">Cancel</button>
            <button onclick="submitAddVideo()" class="px-4 py-2 bg-primary rounded text-sm font-medium hover:bg-blue-600">Add to List</button>
        </div>
    </dialog>

    <!-- Column Visibility Modal -->
    <dialog id="col-modal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-64" style="background-color: #192633; color: white; border: 1px solid #333; z-index: 10000;">
        <h3 class="text-lg font-bold mb-4">Visible Columns</h3>
        <div id="col-list" class="flex flex-col gap-2 max-h-60 overflow-y-auto mb-4">
            <!-- Populated by JS -->
        </div>
        <div class="flex justify-end">
             <button onclick="document.getElementById('col-modal').close()" class="px-4 py-2 bg-primary rounded text-sm hover:bg-blue-600">Done</button>
        </div>
    </dialog>
    <!-- Playlist Management Modal -->
    <dialog id="playlistModal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-96" style="background-color: #192633; color: white; border: 1px solid #333; z-index: 10000;">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-bold">My Playlists</h3>
            <button onclick="document.getElementById('playlistModal').close()" class="text-text-sub hover:text-white"><span class="material-symbols-rounded">close</span></button>
        </div>
        
        <div class="flex gap-2 mb-4">
            <input type="text" id="newPlaylistName" placeholder="New Playlist Name..." class="flex-1 bg-bg-dark border border-border rounded px-3 py-1.5 text-sm focus:border-primary outline-none text-white">
            <button onclick="createNewPlaylist()" class="bg-primary hover:bg-blue-600 px-3 py-1.5 rounded text-sm font-bold flex items-center"><span class="material-symbols-rounded">add</span></button>
        </div>

        <div id="playlist-list-container" class="flex flex-col gap-2 max-h-40 overflow-y-auto mb-4 border-b border-border pb-4">
            <div class="text-center text-text-sub text-xs py-4">Loading playlists... (Login required)</div>
        </div>
        
        <h4 class="text-sm font-bold mb-2">Import from YouTube</h4>
        <div id="yt-playlist-container" class="flex flex-col gap-2 max-h-40 overflow-y-auto">
             <div class="text-center text-text-sub text-xs">Loading YouTube Playlists...</div>
        </div>
    </dialog>

    <!-- Power Search Modal -->
    <dialog id="powerSearchModal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-96" style="background-color: #192633; color: white; border: 1px solid #333; z-index: 10000;">
        <h3 class="text-lg font-bold mb-4 flex items-center gap-2"><span class="material-symbols-rounded text-primary">bolt</span> Power Search</h3>
        
        <label class="text-xs text-text-sub uppercase font-bold tracking-wider mb-1 block">Topic / Keywords</label>
        <input type="text" id="ps-topic" placeholder="e.g. Jazz Piano History" class="input-dark text-white placeholder-gray-500">
        
        <div class="flex gap-4 mb-4">
            <div class="flex-1">
                <label class="text-xs text-text-sub uppercase font-bold tracking-wider mb-1 block">Max Videos</label>
                <input type="number" id="ps-max" value="25" min="5" max="50" class="input-dark text-white placeholder-gray-500">
            </div>
            <div class="flex-1">
                 <label class="text-xs text-text-sub uppercase font-bold tracking-wider mb-1 block">Order</label>
                 <select id="ps-order" class="input-dark text-white"><option value="relevance">Relevance</option><option value="date">Date</option><option value="viewCount">Views</option></select>
            </div>
        </div>

        <div class="flex justify-end gap-2 mt-4">
            <button onclick="document.getElementById('powerSearchModal').close()" class="px-4 py-2 text-sm text-text-sub hover:text-white">Cancel</button>
            <button onclick="executePowerSearch()" class="px-4 py-2 bg-primary rounded text-sm font-medium hover:bg-blue-600 shadow-lg shadow-primary/20">Start Search</button>
        </div>
        <div id="ps-status" class="text-xs text-center mt-2 text-text-sub h-4"></div>
    </dialog>

    <script>
        // --- FALLBACK STUBS (In case Module script fails) ---
        function missingConfigAlert() {
            alert("System Error: Firebase Configuration is missing or the script failed to load.\nPlease check the console for errors and ensure your .env file is correct.");
        }
        
        window.signIn = missingConfigAlert;
        window.openPlaylistModal = missingConfigAlert;
        window.executePowerSearch = missingConfigAlert;
        window.clearWatched = missingConfigAlert;
        
        // Listen for Custom Event to know if loaded
        window.addEventListener('firebase-ready', () => {
            console.log("Firebase Module Verified Ready.");
        });
    </script>

    <script type="module">
        console.log("Starting Firebase Module...");
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, addDoc, deleteDoc, getDocs, orderBy, query, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";



        // --- HELPER FUNCTIONS FOR INTERACTIVITY ---
        
        async function editDate(e, index) {
             e.stopPropagation();
             const item = playlist[index];
             const newDate = prompt("Enter Original Date (YYYY-MM-DD):", item.original_date || "");
             if (newDate === null) return; // Cancel
             
             // Update Local
             item.original_date = newDate;
             renderTable();
             savePlaylist();
             
             // Update Cloud (Optimistic)
             if(window.currentPlaylistId && auth && auth.currentUser) {
                 try {
                     const docRef = doc(db, `users/${auth.currentUser.uid}/playlists/${currentPlaylistId}/videos`, item.firestore_id || item.youtube_id);
                     await setDoc(docRef, { original_date: newDate }, { merge: true });
                 } catch(err) { console.error("Date save failed", err); }
             }
        }

        async function setRating(e, index, value) {
            e.stopPropagation();
            const item = playlist[index];
            
            // Toggle Logic: If clicking active rating, reset to 0? Or just set. Let's just set.
            // Wait, if 5 is selected and I click 5 again, usually unsetting isn't expected in simple UI.
            // But if I want to rate 4, I click 4.
            item.rating = value;
            
            renderTable();
            savePlaylist();
            
             // Update Cloud
             if(window.currentPlaylistId && auth && auth.currentUser) {
                 try {
                      const docRef = doc(db, `users/${auth.currentUser.uid}/playlists/${currentPlaylistId}/videos`, item.firestore_id || item.youtube_id);
                     await setDoc(docRef, { rating: item.rating }, { merge: true });
                 } catch(err) { console.error("Rating save failed", err); }
             }
        }

        // --- GLOBAL EXPORTS (Must be customized per module) ---
        window.editDate = editDate;
        window.setRating = setRating;
        
        window.enrichCloudPlaylist = async () => {
            console.log("Starting Enrichment Process...");
            if (!window.currentPlaylistId || !window.auth.currentUser) {
                alert("Select a cloud playlist first.");
                return;
            }
            
            // Use window.playlist or fallback to empty array
            const currentList = window.playlist || [];
            
            // Filter Logic: Check for null, empty, or placeholder dash
            const candidates = currentList.filter(v => (
                !v.tldr || v.tldr === "-" || 
                !v.tags || v.tags.length === 0
            ));
            
            if (candidates.length === 0) {
                alert("Playlist is fully enriched!");
                return;
            }

            if (!confirm(`Found ${candidates.length} videos missing AI metadata. Enrich now using Gemini?\n(This may take a minute)`)) return;

            const btn = document.querySelector('button[title="AI Enrich Playlist"] span.hidden');
            const originalText = btn ? btn.textContent : "Enrich";
            if(btn) btn.textContent = "Processing...";

            const GEMINI_API_KEY = "{{ gemini_api_key }}"; // Re-defined here for safety
            
            // FIX: Simplified check to avoid Jinja2 parser conflicts
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "None" || GEMINI_API_KEY.length < 20) {
                console.error("API Key Invalid");
                alert("Critical Error: GEMINI_API_KEY is missing or invalid.");
                return;
            }

            let count = 0;
            let successCount = 0;
            let errors = [];

            for (const v of candidates) {
                count++;
                if(btn) btn.textContent = `${count}/${candidates.length}`;
                
                try {
                    if (!v.firestore_id) throw new Error("Missing Firestore ID. Please refresh the page.");

                    const prompt = `
                    Extract metadata for this video:
                    Title: ${v.title}
                    Description: ${v.description || ''}
                    
                    Return JSON: { "tldr": "15 words max", "original_date": "YYYY-MM-DD" or null, "tags": ["tag1", "tag2", "tag3"] }
                    Return ONLY valid JSON.
                    `;
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    
                    const result = await response.json();
                    if (result.error) throw new Error("Gemini API: " + result.error.message);

                    if (!result.candidates || !result.candidates[0]) throw new Error("Gemini API returned no candidates.");

                    const text = result.candidates[0].content.parts[0].text;
                    const jsonText = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    const meta = JSON.parse(jsonText);
                    
                    // Update Firestore
                    await setDoc(doc(db, `users/${auth.currentUser.uid}/playlists/${currentPlaylistId}/videos`, v.firestore_id), {
                        tldr: meta.tldr,
                        original_date: meta.original_date,
                        tags: meta.tags
                    }, { merge: true });
                    
                    // Update UI
                    v.tldr = meta.tldr;
                    v.original_date = meta.original_date;
                    v.tags = meta.tags;
                    renderTable();
                    successCount++;
                    
                } catch (e) {
                    console.error("Enrichment failed for", v.title, e);
                    errors.push(`${v.title.substring(0,20)}... : ${e.message}`);
                }
            }
            
            if(btn) btn.textContent = originalText;
            
            if (errors.length > 0) {
                alert(`Enrichment Finished with Warnings:\nSuccess: ${successCount}\nFailures: ${errors.length}\n\nTop Errors:\n${errors.slice(0, 3).join('\n')}`);
            } else {
                alert(`Enrichment Complete! Updated ${successCount} videos.`);
            }
        };
        console.log("Function Registered: window.enrichCloudPlaylist");
        
        const firebaseConfig = {{ firebase_config | tojson }};
        console.log("Config Status:", firebaseConfig ? "Present" : "Missing");
        
        if (firebaseConfig && firebaseConfig.apiKey) {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);
            const provider = new GoogleAuthProvider();
            provider.addScope('https://www.googleapis.com/auth/youtube.readonly');

            window.auth = auth;
            window.db = db;
            window.watchedHistory = new Set();

            // --- AUTH & PLAYLIST LOGIC ---
            
            window.signIn = () => {
                 console.log("Initiating Sign In...");
                 if (!auth) { alert("Firebase Auth not initialized."); return; }
                 
                 signInWithPopup(auth, provider)
                    .then((result) => {
                        console.log("Sign In Successful", result.user.uid);
                        const credential = GoogleAuthProvider.credentialFromResult(result);
                        window.currentAccessToken = credential.accessToken;
                        
                        loadFirestorePlaylists(result.user.uid);
                        loadWatchedHistory(result.user.uid);
                        if(window.currentAccessToken) loadYouTubePlaylists(window.currentAccessToken);
                    }).catch(e => {
                        console.error("Sign In Failed:", e);
                        alert("Sign In Failed: " + e.message);
                    });
            };
            
            window.signOutUser = () => signOut(auth);

            onAuthStateChanged(auth, async (user) => {
                const container = document.getElementById('user-profile-container');
                if (user) {
                    container.innerHTML = `<img src="${user.photoURL}" class="size-9 rounded-full border border-border cursor-pointer hover:opacity-80 transition-opacity" onclick="window.signOutUser()" title="Sign Out: ${user.displayName}">`;
                    
                    await setDoc(doc(db, "users", user.uid), {
                        uid: user.uid,
                        email: user.email,
                        displayName: user.displayName,
                        photoURL: user.photoURL,
                        lastLogin: new Date().toISOString()
                    }, { merge: true });

                    loadFirestorePlaylists(user.uid);
                    loadWatchedHistory(user.uid);
                    

                    
                    // Auto-Restore Last Playlist
                    const lastId = localStorage.getItem('last_playlist_id');
                    const lastName = localStorage.getItem('last_playlist_name');
                    if (lastId && lastName) {
                        console.log("Restoring last session playlist:", lastName);
                        // Small delay to ensure firestore is fully fully ready? usually not needed inside auth
                        window.switchPlaylist(lastId, lastName);
                    } else {
                        // If no last playlist, maybe load the first one? Or just wait for user.
                        // For now, do nothing.
                    }

                    if(window.currentAccessToken) {
                        loadYouTubePlaylists(window.currentAccessToken);
                    } else {
                        // Show "Connect" prompt
                        const container = document.getElementById('yt-playlist-container');
                        if(container) {
                             container.innerHTML = `
                                <div class="text-center py-4">
                                     <div class="text-xs text-text-sub mb-2">Sign In again to enable Import</div>
                                     <button onclick="window.signIn()" class="text-xs bg-surface border border-border px-3 py-1.5 rounded hover:bg-white/10">Connect YouTube</button>
                                </div>
                             `;
                        }
                    }

                } else {
                     container.innerHTML = `<button onclick="window.signIn()" class="size-9 rounded-full bg-surface border border-border flex items-center justify-center hover:bg-white/10 transition-colors" title="Sign In with Google"><span class="material-symbols-rounded text-sm">person</span></button>`;
                     document.getElementById('current-playlist-name').textContent = "My Playlist";
                }
            });

            // --- HISTORY LOGIC ---
            window.loadWatchedHistory = async (uid) => {
                try {
                    const historyRef = collection(db, `users/${uid}/watched_history`);
                    // Optimization: We check existence. We might not want to download ALL history if it's huge. 
                    // But for client-side filtering we need the IDs.
                    // Let's cap at 1000 recent or use a better strategy later.
                    const q = query(historyRef, orderBy('markedWatchedAt', 'desc'), limit(1000));
                    const snapshot = await getDocs(q);
                    window.watchedHistory.clear();
                    snapshot.forEach(doc => window.watchedHistory.add(doc.id));
                    console.log(`Loaded ${window.watchedHistory.size} watched videos.`);
                } catch (e) {
                    console.error("Error loading history:", e);
                }
            };
            
            window.recordWatchedVideo = async (uid, video) => {
                if (!uid || !video) return;
                try {
                    window.watchedHistory.add(video.youtube_id);
                    await setDoc(doc(db, `users/${uid}/watched_history`, video.youtube_id), {
                        videoId: video.youtube_id,
                        title: video.title,
                        markedWatchedAt: new Date().toISOString()
                    });
                } catch (e) { console.error("History record failed:", e); }
            };

            window.loadYouTubePlaylists = async (accessToken) => {
                const container = document.getElementById('yt-playlist-container');
                try {
                    const response = await fetch(`https://www.googleapis.com/youtube/v3/playlists?part=snippet,contentDetails&mine=true&maxResults=50`, {
                        headers: { 'Authorization': `Bearer ${accessToken}` }
                    });
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error("YouTube API Error:", data.error);
                        container.innerHTML = `
                            <div class="text-xs text-red-300 mb-2">Error: ${data.error.message}</div>
                            <button onclick="window.signIn()" class="text-xs bg-primary px-2 py-1 rounded">Reconnect Google Account</button>
                        `;
                        return;
                    }
                    
                    if(!data.items || data.items.length === 0) { 
                        container.innerHTML = '<div class="text-xs text-text-sub">No playlists found on this account.</div>'; 
                        return; 
                    }
                    
                    container.innerHTML = '';
                    data.items.forEach(item => {
                         const div = document.createElement('div');
                         div.className = "flex justify-between items-center bg-bg-dark p-2 rounded hover:bg-white/5";
                         div.innerHTML = `
                            <div class="truncate text-sm flex-1 pr-2">${item.snippet.title} (${item.contentDetails.itemCount})</div>
                            <button onclick="importYouTubePlaylist('${item.id}', '${item.snippet.title.replace(/'/g, "\\'")}')" class="text-xs bg-surface border border-border px-2 py-1 rounded hover:bg-primary">Import</button>
                         `;
                         container.appendChild(div);
                    });

                } catch (e) {
                    console.error("YT Fetch Error:", e);
                    container.innerHTML = `<div class="text-xs text-red-400">Fetch Failed: ${e.message}</div>`;
                }
            };
            
            window.importYouTubePlaylist = async (ytId, title) => {
                 const name = prompt(`Import "${title}"? Enter name for new cloud playlist:`, title);
                 if(!name) return;
                 
                 const statusDiv = document.getElementById('yt-playlist-container');
                 const originalContent = statusDiv.innerHTML;
                 statusDiv.innerHTML = '<div class="text-xs text-center animate-pulse">Importing videos... this may take a moment.</div>';
                 
                 try {
                     // 1. Create Playlist
                     const user = auth.currentUser;
                     const playlistRef = await addDoc(collection(db, `users/${user.uid}/playlists`), {
                        name: name,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        videoCount: 0,
                        source: 'youtube_import',
                        originalId: ytId
                    });
                    
                    // 2. Fetch Videos (Pages)
                    let nextPageToken = '';
                    let count = 0;
                    
                    do {
                        // Use OAuth Token via Header (Secure) instead of API Key
                        const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${ytId}${nextPageToken ? '&pageToken='+nextPageToken : ''}`;
                        
                        const resp = await fetch(url, {
                             headers: { 'Authorization': `Bearer ${window.currentAccessToken}` }
                        });
                        const data = await resp.json();
                        
                        if (data.error) { throw new Error(data.error.message); }
                        if (!data.items) break;
                        
                        const batch = [];
                        for(const item of data.items) {
                            const v = {
                                title: item.snippet.title,
                                youtube_id: item.snippet.resourceId.videoId,
                                channel: item.snippet.videoOwnerChannelTitle || "Unknown",
                                published_at: item.snippet.publishedAt,
                                added_at: new Date().toISOString(),
                                watched: false,
                                notes: ""
                            };
                            await addDoc(collection(db, `users/${user.uid}/playlists/${playlistRef.id}/videos`), v);
                            count++;
                        }
                        nextPageToken = data.nextPageToken;
                        
                    } while (nextPageToken && count < 200); // Cap at 200 for safety
                    
                    await setDoc(playlistRef, { videoCount: count }, { merge: true });
                    
                    await setDoc(playlistRef, { videoCount: count }, { merge: true });
                    
                    // Auto-switch to the new playlist
                    loadFirestorePlaylists(user.uid); 
                    window.switchPlaylist(playlistRef.id, name);
                    
                    statusDiv.innerHTML = originalContent;
                    
                 } catch (e) {
                     console.error("Import Failed:", e);
                     alert("Import Failed: " + e.message);
                     statusDiv.innerHTML = originalContent;
                 }
            };

            // --- FIRESTORE PLAYLIST FUNCTIONS ---
            
            window.loadFirestorePlaylists = async (uid) => {
                const listContainer = document.getElementById('playlist-list-container');
                listContainer.innerHTML = '<div class="text-center text-text-sub text-xs">Loading...</div>';
                
                try {
                    const playlistsRef = collection(db, `users/${uid}/playlists`);
                    const q = query(playlistsRef, orderBy('updatedAt', 'desc'));
                    const snapshot = await getDocs(q);
                    
                    listContainer.innerHTML = '';
                    
                    if (snapshot.empty) {
                        listContainer.innerHTML = '<div class="text-center text-text-sub text-xs">No playlists found. Create one!</div>';
                        return;
                    }

                    snapshot.forEach(docSnap => {
                        const data = docSnap.data();
                        const div = document.createElement('div');
                        div.className = "p-2 hover:bg-white/5 rounded flex justify-between items-center group";
                        // Click on main area to switch
                        div.innerHTML = `
                            <div class="flex items-center gap-2 flex-1 cursor-pointer" onclick="window.switchPlaylist('${docSnap.id}', '${data.name.replace(/'/g, "\\'")}')">
                                <span class="material-symbols-rounded text-primary text-sm">folder</span>
                                <span class="text-sm font-medium ${window.currentPlaylistId === docSnap.id ? 'text-primary' : 'text-gray-300'}">${data.name}</span>
                                <span class="text-xs text-text-sub ml-2">(${data.videoCount || 0})</span>
                            </div>
                            <button onclick="deletePlaylist('${docSnap.id}', '${data.name.replace(/'/g, "\\'")}')" class="text-text-sub hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity p-1" title="Delete Playlist">
                                <span class="material-symbols-rounded text-sm">delete</span>
                            </button>
                        `;
                        listContainer.appendChild(div);
                    });
                } catch (e) {
                    console.error("Error loading playlists:", e);
                    listContainer.innerHTML = `<div class="text-red-400 text-xs text-center">Error loading playlists: ${e.message}</div>`;
                }
            };
            
            window.deletePlaylist = async (playlistId, name) => {
                if(!confirm(`Are you sure you want to delete "${name}"?\nThis cannot be undone.`)) return;
                
                try {
                    await deleteDoc(doc(db, `users/${auth.currentUser.uid}/playlists`, playlistId));
                    // Note: Subcollections (videos) are not automatically deleted by client SDK in Firestore, 
                    // but they become inaccessible via the UI, which is sufficient for this scope.
                    
                    if (window.currentPlaylistId === playlistId) {
                        window.currentPlaylistId = null;
                        document.getElementById('current-playlist-name').textContent = "My Playlist (Local)";
                        // Fallback to local
                        const local = JSON.parse(localStorage.getItem('my_playlist_v3')) || [];
                        window.updatePlaylistData(local);
                    }
                    
                    loadFirestorePlaylists(auth.currentUser.uid);
                    
                } catch (e) {
                    console.error("Delete Failed:", e);
                    alert("Delete Failed: " + e.message);
                }
            };

            window.createNewPlaylist = async () => {
                const nameInput = document.getElementById('newPlaylistName');
                const name = nameInput.value.trim();
                const user = auth.currentUser;
                
                if (!name || !user) return;

                try {
                    const docRef = await addDoc(collection(db, `users/${user.uid}/playlists`), {
                        name: name,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        videoCount: 0,
                        settings: {}
                    });
                    
                    nameInput.value = '';
                    loadFirestorePlaylists(user.uid); // Refresh list
                    switchPlaylist(docRef.id, name); // Auto switch
                    
                } catch (e) {
                    console.error("Error creating playlist:", e);
                    alert("Failed to create playlist");
                }
            };

            window.switchPlaylist = async (playlistId, name) => {
                const user = auth.currentUser;
                if (!user) return;

                window.currentPlaylistId = playlistId;
                document.getElementById('current-playlist-name').textContent = name;
                
                // Save state for restore
                localStorage.setItem('last_playlist_id', playlistId);
                localStorage.setItem('last_playlist_name', name);
                
                document.getElementById('playlistModal').close();

                // Load Videos
                const listContainer = document.getElementById('tableBody');
                listContainer.innerHTML = '<tr><td colspan="10" class="text-center p-8">Loading videos...</td></tr>';
                
                try {
                    const videosRef = collection(db, `users/${user.uid}/playlists/${playlistId}/videos`);
                    const q = query(videosRef, orderBy('added_at', 'desc')); // Matches import field name
                    const snapshot = await getDocs(q);
                    
                    const videos = [];
                    snapshot.forEach(doc => {
                        // FIX: Do not overwrite youtube_id with doc.id. 
                        // Import saves 'youtube_id' correctly in data. 
                        // Map doc.id to 'firestore_id' for delete operations.
                        const data = doc.data();
                        videos.push({ 
                            ...data, 
                            firestore_id: doc.id,
                            // Ensure backward compatibility if someone manually saved doc ID as youtube_id
                            youtube_id: data.youtube_id || doc.id 
                        });
                    });
                    
                    // Update Legacy App State
                    if (window.updatePlaylistData) {
                        window.updatePlaylistData(videos);
                    }
                    
                } catch (e) {
                    console.error("Error loading videos:", e);
                    alert("Failed to load videos.");
                }
            };

            // --- FIRESTORE WRITE FUNCTIONS ---

            window.firestoreAddVideo = async (playlistId, videoData) => {
                const user = auth.currentUser;
                if (!user) return;
                try {
                    // Use video ID as doc ID to prevent duplicates
                    const vidId = videoData.youtube_id;
                    const docRef = doc(db, `users/${user.uid}/playlists/${playlistId}/videos`, vidId);
                    
                    await setDoc(docRef, {
                        ...videoData,
                        addedAt: new Date().toISOString()
                    });
                    
                    // Update Playlist Config (Count) - Optional but good for UI
                    // We skip inc count for speed or do it via Cloud Function, but simpler to just ignore or separate write.
                    
                } catch (e) {
                    console.error("Firestore Add Failed:", e);
                    throw e;
                }
            };

            window.firestoreDeleteVideo = async (playlistId, videoId) => {
                const user = auth.currentUser;
                if (!user) return;
                try {
                    await deleteDoc(doc(db, `users/${user.uid}/playlists/${playlistId}/videos`, videoId));
                } catch (e) {
                    console.error("Firestore Delete Failed:", e);
                    throw e;
                }
            };

             // Expose Functions globally
            window.openPlaylistModal = () => {
                console.log("Attempting to open Playlists Modal...");
                const modal = document.getElementById('playlistModal');
                if(!modal) { alert("Error: Playlist Modal UI missing."); return; }
                
                modal.showModal();
                console.log("Modal showModal() called.");
                
                if (window.auth && window.auth.currentUser) {
                    loadFirestorePlaylists(window.auth.currentUser.uid);
                } else {
                    document.getElementById('playlist-list-container').innerHTML = 
                        '<div class="text-center text-text-sub text-xs py-4">Please Sign In to manage cloud playlists.</div>';
                }
            };

        } else {
             console.error("Firebase Config Missing!");
        }
    </script>

    <script>
        const INJECTED_DATA = {{ videos_json }};
        // Data Structure Update: Ensure new fields exist
        let playlist = JSON.parse(localStorage.getItem('my_playlist_v3')) || INJECTED_DATA.map(v => ({
            ...v,
            tags: v.tags || [],
            original_date: v.published_at || '', 
            watched: false
        }));
        
        // Sync to Window for Module Access
        window.playlist = playlist;
        
        // Expose Update Function for Module Script
        window.updatePlaylistData = (newVideos) => {
            console.log("Updating Playlist Data:", newVideos.length);
            playlist = newVideos;
            window.playlist = newVideos; // Keep synced
            renderTable();
        };

        // --- STATE VARIABLES ---
        let sortState = { col: null, asc: true };
        let selectedIndices = new Set();
        let lastSelectedIndex = -1; 
        let draggedItemIndex = null;
        let activeVideoId = null;
        let currentIndex = -1; 
        let player = null;
        let fetchTimeout = null;
        
        // Search & Filter
        let searchTerm = ""; // New Search State

        // Column Config
        // Key matching the data field or logical ID
        // Initialize Config
        const defaultVisible = {
            index: true, watched: true, thumbnail: true, title: true, tldr: true,
            original_date: true, published_at: true, channel: true, desc: true,
            tags: true, duration: true, rating: true, notes: true
        };
        let visibleColumns = JSON.parse(localStorage.getItem('visible_cols')) || defaultVisible;

        // --- COLUMN CONFIG ---
        const columnsConfig = [
            { key: 'watched', label: 'Watched', cls: 'col-watched', sortable: false },
            { key: 'thumbnail', label: 'Thumbnail', cls: 'col-thumbnail', sortable: false },
            { key: 'title', label: 'Title', cls: 'col-title', sortable: true },
            { key: 'tldr', label: 'TL;DR', cls: 'col-tldr', sortable: false },
            { key: 'original_date', label: 'Orig. Date', cls: 'col-original_date', sortable: true },
            { key: 'published_at', label: 'Upload Date', cls: 'col-published_at', sortable: true },
            { key: 'channel', label: 'Channel', cls: 'col-channel', sortable: true },
            { key: 'tags', label: 'Tags', cls: 'col-tags', sortable: false },
            { key: 'rating', label: 'Rating', cls: 'col-rating', sortable: true },
            { key: 'notes', label: 'Notes', cls: 'col-notes', align: 'text-center', sortable: false }
        ];

        // --- RENDER HEADERS ---
        function renderHeaders() {
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            const tr = document.createElement('tr');
            
            // STATIC LOCKED COLUMNS
            // 1. Index (Sticky Left)
            const thIndex = document.createElement('th');
            thIndex.className = "px-4 py-3 sticky left-0 z-30 bg-bg-dark border-b border-border text-center w-12 min-w-[3rem]";
            thIndex.innerHTML = '<span class="select-none">#</span>';
            tr.appendChild(thIndex);
            
            // STATIC COLUMNS (No Resizing)
            const staticCols = ['watched', 'thumbnail', 'original_date', 'published_at', 'rating'];

            columnsConfig.forEach(col => {
                if (!visibleColumns[col.key]) return;

                const th = document.createElement('th');
                // Added sticky, top-0, z-20, bg-bg-dark for sticky headers
                let classes = "px-4 py-3 relative sticky top-0 z-20 bg-bg-dark box-border border-b border-border "; 
                
                // Add resizable class only if NOT static
                if (!staticCols.includes(col.key)) {
                    classes += "resizable-col ";
                }

                if (col.cls) classes += col.cls + " "; 
                
                // Priority: Custom Width > Config Width > Auto
                if (customWidths[col.key]) {
                    th.style.width = customWidths[col.key] + 'px';
                    th.style.minWidth = customWidths[col.key] + 'px';
                    th.style.maxWidth = customWidths[col.key] + 'px';
                } else {
                    if (col.width) classes += col.width + " ";
                }
                
                if (col.align) classes += col.align + " ";
                th.className = classes;
                th.id = 'th-' + col.key;

                // 1. Label Container (The ONLY clickable sort target)
                const labelSpan = document.createElement('span');
                labelSpan.className = "flex items-center gap-1 truncate w-full h-full select-none";
                labelSpan.textContent = col.label;

                const isSortable = col.sortable; // Use config property
                
                if (isSortable) {
                    labelSpan.classList.add("cursor-pointer", "hover:text-white");
                    labelSpan.onclick = (e) => {
                        e.stopPropagation(); // Stop bubbling
                        sortPlaylist(col.key);
                    };
                    
                    // Add Sort Indicator
                    if (sortState.col === col.key) {
                        const arrow = document.createElement('span');
                        arrow.className = "text-[10px] ml-1";
                        arrow.textContent = sortState.asc ? '▲' : '▼';
                        labelSpan.appendChild(arrow);
                    }
                }
                
                th.appendChild(labelSpan);

                // 2. Resizer (Sibling to label, does NOT trigger sort)
                // ONLY add resizer if NOT a static column
                if (!staticCols.includes(col.key)) {
                    const resizer = document.createElement('div');
                    resizer.className = 'col-resizer';
                    // Inline styles to ensure hit area is correct and independent
                    resizer.style.position = 'absolute';
                    resizer.style.right = '0';
                    resizer.style.top = '0';
                    resizer.style.bottom = '0';
                    resizer.style.width = '12px'; // Wide hit area
                    resizer.style.cursor = 'col-resize';
                    resizer.style.zIndex = '10';
                    resizer.style.transform = 'translateX(50%)';
                    
                    th.appendChild(resizer);
                }

                tr.appendChild(th);
            });
            thead.appendChild(tr);
            
            makeColumnsResizable();
        }
        let isDraggingScrubber = false;
        
        // Helper: Format Seconds to MM:SS
        function formatTime(seconds) {
            if (!seconds) return "0:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        }

        // Initialize Scrubber Events safely after DOM load
        document.addEventListener('DOMContentLoaded', () => {
            const scrubber = document.getElementById('scrubber');
            if (scrubber) {
                scrubber.oninput = function() {
                    isDraggingScrubber = true;
                    document.getElementById('time-current').textContent = formatTime(this.value);
                };

                scrubber.onchange = function() {
                    isDraggingScrubber = false;
                    if (player && player.seekTo) {
                        player.seekTo(parseFloat(this.value), true);
                    }
                };
            }
        });

        // Update Loop (500ms)
        setInterval(() => {
            if (!player || !player.getCurrentTime) return;
            
            const duration = player.getDuration();
            const current = player.getCurrentTime();

            // Always update Total Time & Scrubber Max
            if (duration) {
                document.getElementById('time-total').textContent = formatTime(duration);
                const scrubber = document.getElementById('scrubber');
                if (scrubber) scrubber.max = duration;
            }

            // Sync Scrubber Position (if not dragging)
            if (!isDraggingScrubber) {
                document.getElementById('time-current').textContent = formatTime(current);
                const scrubber = document.getElementById('scrubber');
                if (scrubber) scrubber.value = current;
                
                // Update Transport Play Button Icon
                const state = player.getPlayerState();
                const btnIcon = document.querySelector('#btn-transport-play span');
                // 1 = Playing, 2 = Paused
                if (btnIcon) btnIcon.textContent = (state === 1) ? 'pause' : 'play_arrow';
            }
        }, 500);

        // Load Custom Widths (Fix for Snap Back)
        let customWidths = JSON.parse(localStorage.getItem('col_widths')) || {};

        // Initialize Events safely after DOM load
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Scrubber Events
            const scrubber = document.getElementById('scrubber');
            if (scrubber) {
                scrubber.oninput = function() {
                    isDraggingScrubber = true;
                    document.getElementById('time-current').textContent = formatTime(this.value);
                };

                scrubber.onchange = function() {
                    isDraggingScrubber = false;
                    if (player && player.seekTo) {
                        player.seekTo(parseFloat(this.value), true);
                    }
                };
            }

            // 2. Column Modal Event
            document.getElementById('btn-cols').addEventListener('click', () => {
                const list = document.getElementById('col-list');
                list.innerHTML = '';
    
                // "Select All" Checkbox
                const allChecked = columnsConfig.every(col => visibleColumns[col.key]);
                
                const selectAllDiv = document.createElement('div');
                selectAllDiv.className = "flex items-center gap-2 p-1.5 hover:bg-white/5 rounded pb-2 mb-2 border-b border-white/10";
                selectAllDiv.innerHTML = `
                    <input type="checkbox" ${allChecked ? 'checked' : ''} onchange="toggleAllColumns(this.checked)" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer">
                    <span class="text-xs text-white uppercase font-bold tracking-wider">Select All</span>
                `;
                list.appendChild(selectAllDiv);
    
                // Individual Columns
                columnsConfig.forEach(col => {
                    const div = document.createElement('div');
                    div.className = "flex items-center gap-2 p-1.5 hover:bg-white/5 rounded";
                    div.innerHTML = `
                        <input type="checkbox" ${visibleColumns[col.key] ? 'checked' : ''} onchange="toggleColumn('${col.key}')" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer">
                        <span class="text-sm text-text-sub">${col.label}</span>
                    `;
                    list.appendChild(div);
                });
                
                document.getElementById('col-modal').showModal();
            });
        });

        function toggleAllColumns(isChecked) {
            columnsConfig.forEach(col => {
                visibleColumns[col.key] = isChecked;
            });
            localStorage.setItem('visible_cols', JSON.stringify(visibleColumns));
            
            // Re-render modal to show updated state immediately (optional, or just close)
            // Ideally we re-populate the list, but for now let's just re-render grid
            renderHeaders();
            renderTable();
            
            // Close and re-open to refresh checkboxes? Or simpler: manually update DOM
            // Let's just re-trigger the modal render logic if it's open
            const modal = document.getElementById('col-modal');
            if (modal.open) {
                document.getElementById('btn-cols').click(); // fast re-render hack or extract render function
                modal.showModal(); // ensure open
            }
        }

        function toggleColumn(key) {
            visibleColumns[key] = !visibleColumns[key];
            localStorage.setItem('visible_cols', JSON.stringify(visibleColumns));
            renderHeaders();
            renderTable();
            
            // Check Select All state
            const allChecked = columnsConfig.every(col => visibleColumns[col.key]);
            const selectAllBox = document.querySelector('#col-list input[onchange^="toggleAllColumns"]');
            if(selectAllBox) selectAllBox.checked = allChecked;
        }

        // --- RENDER TABLE ---
        function renderTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            // 1. Filter
            let filteredPlaylist = playlist.map((item, index) => ({ item, originalIndex: index }));
            
            if (searchTerm) {
                filteredPlaylist = filteredPlaylist.filter(wrapper => {
                    const i = wrapper.item;
                    const text = (i.title + ' ' + i.channel + ' ' + (i.tags||[]).join(' ')).toLowerCase();
                    return text.includes(searchTerm);
                });
            }

            // 2. Render Rows
            filteredPlaylist.forEach(({ item, originalIndex }) => {
                const vidId = item.youtube_id;
                const isActive = (vidId === activeVideoId);
                const isSelected = selectedIndices.has(originalIndex);

                const tr = document.createElement('tr');
                let classes = "group transition-colors cursor-pointer select-none "; 
                if (isActive) classes += "row-active "; 
                else if (isSelected) classes += "row-selected ";
                else classes += "hover:bg-surface ";
                
                tr.className = classes;
                if (isActive) {
                    // Use a SOLID dark blue color mixed with the background to ensure visibility
                    // bg-dark is #101922. Primary is #137fec. 
                    // Let's use a manually calculated dark blue hex that stands out against #101922
                    tr.style.setProperty('background-color', '#1c2e42', 'important'); 
                    tr.style.setProperty('border-left', '4px solid #137fec', 'important');
                    tr.style.fontWeight = "600"; // Make text bold
                    tr.style.color = "#ffffff"; // Force white text
                }
                
                // Events (Use originalIndex for logic)
                tr.setAttribute('draggable', 'true');
                tr.ondragstart = (e) => handleDragStart(e, originalIndex);
                tr.ondragend = (e) => handleDragEnd(e);
                tr.ondragover = (e) => handleDragOver(e, originalIndex);
                tr.ondragleave = (e) => handleDragLeave(e, originalIndex);
                tr.ondrop = (e) => handleDrop(e, originalIndex);
                tr.onclick = (e) => handleRowClick(e, originalIndex);
                tr.ondblclick = () => loadVideoByIndex(originalIndex);

                // Data Prep
                const thumbnail = item.thumbnail_url || `https://img.youtube.com/vi/${vidId}/default.jpg`;
                const tldr = item.tldr || "-"; 
                const desc = "-"; 
                const rating = "☆☆☆☆☆";
                const tags = item.tags || [];

                // Dynamic Column Rendering
                let html = '';
                
                // 1. Index (Locked Sticky)
                // Use standard filled triangle symbol 'play_arrow' but force FILL via variation settings
                // and keep size constrained to avoid row height blowout
                html += `<td class="text-center font-mono text-xs col-index sticky left-0 z-30 bg-bg-dark border-r border-white/5">${isActive ? 
                    '<span class="material-symbols-rounded text-primary" style="font-size: 28px; font-variation-settings: \'FILL\' 1; vertical-align: middle;">play_arrow</span>' 
                    : (originalIndex + 1)}</td>`;
                
                // Dynamic Cols
                if (visibleColumns.watched) html += `<td class="text-center col-watched"><input type="checkbox" ${item.watched ? 'checked' : ''} onclick="toggleWatched(event, ${originalIndex})" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer"></td>`;
                
                if (visibleColumns.thumbnail) html += `<td class="text-center p-1 col-thumbnail"><img src="${thumbnail}" style="height: 30px; border-radius: 2px; margin: auto;"></td>`;
                
                if (visibleColumns.title) html += `<td class="font-medium text-white col-title" title="${item.title}">${item.title}</td>`;
                
                if (visibleColumns.tldr) html += `<td class="text-xs text-text-sub col-tldr">${tldr}</td>`;
                
                if (visibleColumns.original_date) html += `<td class="text-xs font-mono text-text-sub col-original_date hover:text-white cursor-pointer" onclick="editDate(event, ${originalIndex})" title="Click to Edit">${item.original_date || '-'}</td>`;
                
                if (visibleColumns.published_at) html += `<td class="text-xs font-mono text-text-sub col-published_at">${item.published_at || '-'}</td>`;
                
                if (visibleColumns.channel) html += `<td class="text-sm text-text-sub col-channel">${item.channel || ''}</td>`;
                
                if (visibleColumns.tags) {
                     const tagHtml = tags.map(t => `<span class="tag-pill">${t} <span class="tag-remove" onclick="removeTag(${originalIndex}, '${t}')">×</span></span>`).join('');
                     html += `<td class="col-tags">${tagHtml} <span class="tag-add" onclick="addNewTag(${originalIndex})">+</span></td>`;
                }
                
                if (visibleColumns.rating) {
                    const stars = [1,2,3,4,5].map(n => 
                        `<span class="cursor-pointer hover:text-yellow-400 ${n <= (item.rating || 0) ? 'text-yellow-500' : 'text-gray-700'}" onclick="setRating(event, ${originalIndex}, ${n})">★</span>`
                    ).join('');
                     html += `<td class="text-center text-lg leading-none pb-1 col-rating whitespace-nowrap cursor-pointer hover:bg-white/5" onclick="setRating(event, ${originalIndex}, 0)" title="Click stars to rate, click empty space to clear.">${stars}</td>`;
                }
                
                if (visibleColumns.notes) html += `<td class="text-center col-notes">${localStorage.getItem('note_' + vidId) ? '<span class="material-symbols-rounded text-xs text-primary">description</span>' : ''}</td>`;

                tr.innerHTML = html;
                
                // CRITICAL FIX: Override cell backgrounds (especially Sticky Index)
                if (isActive) {
                    Array.from(tr.children).forEach(td => {
                        // Use !important to override any class-based bg colors (like bg-bg-dark on sticky col)
                        // Using a semi-transparent blue that sits on top of the dark theme
                        td.style.setProperty('background-color', 'rgba(19, 127, 236, 0.3)', 'important');
                    });
                }

                tbody.appendChild(tr);
            });
        }

        // --- SORTING LOGIC ---
        function sortPlaylist(key) {
            // Toggle sort state
            if (sortState.col === key) {
                sortState.asc = !sortState.asc;
            } else {
                sortState.col = key;
                sortState.asc = true;
            }

            // Sort logic
            playlist.sort((a, b) => {
                let valA = a[key];
                let valB = b[key];
                
                // Handle missing (null/falsy) values - push to bottom?
                if (valA === undefined || valA === null) valA = '';
                if (valB === undefined || valB === null) valB = '';

                // Numeric Check
                if (typeof valA === 'number' && typeof valB === 'number') {
                     return sortState.asc ? valA - valB : valB - valA;
                }
                
                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();
                
                if (valA < valB) return sortState.asc ? -1 : 1;
                if (valA > valB) return sortState.asc ? 1 : -1;
                return 0;
            });
            
            // Re-render
            renderHeaders(); 
            renderTable();
        }

        // --- ROW SELECTION ---
        function handleRowClick(e, index) {
            if (e.shiftKey && lastSelectedIndex !== -1) {
                const start = Math.min(lastSelectedIndex, index);
                const end = Math.max(lastSelectedIndex, index);
                selectedIndices.clear();
                for (let i = start; i <= end; i++) selectedIndices.add(i);
            } else if (e.metaKey || e.ctrlKey) {
                if (selectedIndices.has(index)) selectedIndices.delete(index);
                else selectedIndices.add(index);
                lastSelectedIndex = index;
            } else {
                selectedIndices.clear();
                selectedIndices.add(index);
                lastSelectedIndex = index;
            }
            renderTable();
        }

        // --- DRAG & DROP ---
        function handleDragStart(e, index) {
            draggedItemIndex = index;
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('opacity-50');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('opacity-50');
            document.querySelectorAll('tr').forEach(el => el.classList.remove('drag-over'));
        }

        function handleDragOver(e, index) {
            e.preventDefault(); 
            if (index === draggedItemIndex) return;
            e.currentTarget.classList.add('drag-over');
        }
        
        function handleDragLeave(e, index) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e, index) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (draggedItemIndex === null || draggedItemIndex === index) return;
            
            const item = playlist.splice(draggedItemIndex, 1)[0];
            playlist.splice(index, 0, item);
            
            draggedItemIndex = null;
            savePlaylist();
            renderTable();
        }

        // --- DRAG TO RESIZE COLUMNS (FIXED: STRICT DIRECTIONALITY V3) ---
        function makeColumnsResizable() {
            const table = document.querySelector('table');
            
            // Critical: Enable fixed layout
            table.style.tableLayout = 'fixed'; 
            table.style.boxSizing = 'border-box';

            document.querySelectorAll('.col-resizer').forEach(resizer => {
                // Double protection against sort
                resizer.onclick = (e) => e.stopPropagation();

                resizer.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation(); 
                    
                    const th = resizer.parentElement;
                    const colKey = th.id.replace('th-', ''); 
                    
                    const startX = e.pageX; 
                    const startWidth = th.offsetWidth;
                    // measure exact current pixel width to avoid "jumping"
                    const startTableWidth = table.getBoundingClientRect().width; 
                    
                    // 1. FREEZE TABLE PIXELS 
                    // (prevent auto-stretch behavior during resize)
                    table.style.width = startTableWidth + 'px';
                    table.style.minWidth = startTableWidth + 'px';
                    table.style.maxWidth = 'none';

                    function onMouseMove(moveEvent) {
                        moveEvent.preventDefault();
                        
                        const currentX = moveEvent.pageX;
                        const delta = currentX - startX;
                        
                        // 2. CALCULATE NEW WIDTHS
                        const newColWidth = Math.max(40, startWidth + delta);
                        const effectiveDelta = newColWidth - startWidth; // Actual change after min-width check
                        
                        // 3. APPLY (Target + Table ONLY)
                        // By changing the table width by exactly the same amount as the column,
                        // we insure the "slack" is taken up by the table's total size,
                        // preventing any other columns from shifting.
                        th.style.width = newColWidth + 'px';
                        th.style.minWidth = newColWidth + 'px';
                        th.style.maxWidth = newColWidth + 'px';

                        table.style.width = (startTableWidth + effectiveDelta) + 'px';
                        table.style.minWidth = (startTableWidth + effectiveDelta) + 'px';
                    }

                    function onMouseUp(e) {
                         window.removeEventListener('mousemove', onMouseMove);
                         window.removeEventListener('mouseup', onMouseUp);
                        
                         // Save preference
                         if (colKey) {
                             const finalW = parseFloat(th.style.width);
                             customWidths[colKey] = finalW;
                             localStorage.setItem('col_widths', JSON.stringify(customWidths));
                         }
                    }

                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                });
                
                resizer.addEventListener('click', e => e.stopPropagation());
            });
        }

        // --- TAG MANAGEMENT ---
        function removeTag(index, tagText) {
            const vid = playlist[index];
            if (!vid.tags) return;
            vid.tags = vid.tags.filter(t => t !== tagText);
            savePlaylist();
            renderTable();
        }

        function addNewTag(index) {
            const newTag = prompt("Enter new tag:");
            if (newTag && newTag.trim() !== "") {
                if (!playlist[index].tags) playlist[index].tags = [];
                playlist[index].tags.push(newTag.trim());
                savePlaylist();
                renderTable();
            }
        }

        // --- NEW LOGIC: WATCHED TOGGLE ---
        function toggleWatched(e, index) {
            e.stopPropagation(); // Stop click from selecting row
            playlist[index].watched = !playlist[index].watched;
            savePlaylist();
        }

        // --- FETCH METADATA ---
        function debounceFetch() { clearTimeout(fetchTimeout); fetchTimeout = setTimeout(fetchMetadata, 500); }

        async function fetchMetadata() {
            const url = document.getElementById('newUrl').value;
            if (url.length < 10) return;
            document.getElementById('newTitle').placeholder = "Fetching...";
            
            try {
                const res = await fetch(`https://noembed.com/embed?url=${url}`);
                const data = await res.json();
                if (data.title) {
                    document.getElementById('newTitle').value = data.title;
                    document.getElementById('newChannel').value = data.author_name;
                }
            } catch (e) { console.error(e); }
        }

        // --- PLAYLIST MANAGEMENT ---
        const modal = document.getElementById('addModal');
        function openAddModal() { modal.showModal(); }
        function closeAddModal() { modal.close(); }

        const GEMINI_API_KEY = "{{ gemini_api_key }}";

        async function executePowerSearch() {
            const topic = document.getElementById('ps-topic').value;
            const max = document.getElementById('ps-max').value;
            const order = document.getElementById('ps-order').value;
            const statusFn = (msg) => document.getElementById('ps-status').textContent = msg;

            if (!topic) { statusFn("Please enter a topic."); return; }
            if (!window.currentAccessToken) { 
                statusFn("Session Expired: Please Logout & Login again."); 
                return;
            }

            statusFn("Searching YouTube...");
            
            try {
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(topic)}&type=video&maxResults=${max}&order=${order}`;
                const res = await fetch(url, {
                    headers: { 'Authorization': `Bearer ${window.currentAccessToken}` }
                });
                
                const data = await res.json();
                if (data.error) {
                    throw new Error(data.error.message);
                }

                statusFn(`Found ${data.items.length} videos. Filtering...`);
                
                let addedCount = 0;
                for (const item of data.items) {
                    const vidId = item.id.videoId;
                    // Dedupe against Current Playlist
                    if (playlist.find(v => v.youtube_id === vidId)) continue;
                    
                    // Dedupe against Watched History (Ghost Record)
                    if (window.watchedHistory && window.watchedHistory.has(vidId)) {
                        console.log("Skipping Watched Video:", vidId);
                        continue;
                    }

                    const newVideo = {
                        youtube_id: vidId,
                        title: item.snippet.title,
                        channel: item.snippet.channelTitle,
                        thumbnail_url: item.snippet.thumbnails.high.url || item.snippet.thumbnails.default.url,
                        duration: "-", // Search API doesn't give duration, requires 2nd fetch
                        published_at: item.snippet.publishedAt.split('T')[0],
                        watched: false,
                        tldr: "-", 
                        original_date: null,
                        tags: [topic], // Add search topic as tag
                        rating: 0
                    };

                    // Add to List
                    playlist.unshift(newVideo);
                    
                    if (window.currentPlaylistId && window.firestoreAddVideo) {
                        await window.firestoreAddVideo(window.currentPlaylistId, newVideo);
                    }
                    addedCount++;
                }

                if (!window.currentPlaylistId) savePlaylist();
                renderTable();
                
                statusFn(`Added ${addedCount} new videos.`);
                setTimeout(() => {
                    document.getElementById('powerSearchModal').close();
                    statusFn("");
                }, 1500);

            } catch (e) {
                console.error("Power Search Error", e);
                statusFn("Error: " + e.message);
            }
        }



        async function enrichVideo(title, description) {
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "None") {
                console.warn("No Gemini API Key found. Skipping enrichment.");
                return {};
            }

            const prompt = `
            You are a Metadata Librarian.
            Title: ${title}
            Description: ${description || "No description provided."}

            Return ONLY valid JSON:
            {
              "tldr": "A 15-word max engaging summary.",
              "original_date": "YYYY-MM-DD" (or null if unknown),
              "tags": ["tag1", "tag2", "tag3", "tag4"] (Max 5 lowercase tags)
            }
            `;

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Clean markdown
                const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
                return JSON.parse(cleanText);

            } catch (e) {
                console.error("Enrichment failed:", e);
                return {};
            }
        }

        async function submitAddVideo() {
            const url = document.getElementById('newUrl').value;
            if (!url) return;

            // Extract ID
            let vidId = '';
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            if (match && match[2].length === 11) {
                vidId = match[2];
            } else {
                alert("Invalid YouTube URL");
                return;
            }

            const btn = document.querySelector('#addModal button.bg-primary');
            const originalBtnText = btn.textContent;
            btn.textContent = "Analyzing...";
            btn.disabled = true;

            try {
                // 1. Basic Metadata (Noembed)
                // Use a CORS proxy if needed, or helper. For now direct Noembed usually has CORS headers.
                const noembedUrl = `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${vidId}`;
                
                const res = await fetch(noembedUrl);
                const data = await res.json();
                
                const title = data.title || (document.getElementById('newTitle').value || "Unknown Title");
                const author = data.author_name || (document.getElementById('newChannel').value || "Unknown Channel");
                const thumb = `https://img.youtube.com/vi/${vidId}/hqdefault.jpg`;

                // 2. AI Enrichment
                console.log("Enriching video...");
                const enrichment = await enrichVideo(title, ""); 
                
                const newVideo = {
                    youtube_id: vidId,
                    title: title,
                    channel: author,
                    thumbnail_url: thumb,
                    duration: "VOD", 
                    published_at: new Date().toISOString().split('T')[0],
                    watched: false,
                    tldr: enrichment.tldr || "-",
                    original_date: enrichment.original_date || new Date().toISOString().split('T')[0],
                    tags: enrichment.tags || [],
                    rating: 0
                };

                playlist.unshift(newVideo);
                
                // Persistence Logic
                if (window.currentPlaylistId && window.firestoreAddVideo) {
                    // Fire & Forget (Optimistic UI already updated above, but list might re-render from server sort)
                    // Actually, if we just unshift locally, it appears instantly.
                    // But if we reload, it comes from server.
                    // Let's await to be safe? Or async.
                    window.firestoreAddVideo(window.currentPlaylistId, newVideo);
                } else {
                    savePlaylist();
                }

                renderTable();
                closeAddModal();
                
                // Clear inputs
                document.getElementById('newUrl').value = '';
                document.getElementById('newTitle').value = '';
                document.getElementById('newChannel').value = '';
                document.getElementById('newTags').value = '';

            } catch (e) {
                console.error(e);
                alert("Error adding video: " + e.message);
            } finally {
                btn.textContent = originalBtnText;
                btn.disabled = false;
            }
        }

        function deleteSelected() {
            if (selectedIndices.size === 0) return;
            if (confirm(`Delete ${selectedIndices.size} selected video(s)?`)) {
                // Delete in reverse order
                const indices = Array.from(selectedIndices).sort((a, b) => b - a);
                
                indices.forEach(idx => {
                    const vid = playlist[idx];
                    // Persistence Logic
                    if (window.currentPlaylistId && window.firestoreDeleteVideo && vid.youtube_id) {
                        window.firestoreDeleteVideo(window.currentPlaylistId, vid.youtube_id);
                    }
                    playlist.splice(idx, 1);
                });
                
                selectedIndices.clear();
                lastSelectedIndex = -1;
                
                if (!window.currentPlaylistId) {
                    savePlaylist(); // Local Storage only if not Cloud
                }
                renderTable();
            }
        }

        async function clearWatched() {
            const watched = playlist.filter(v => v.watched);
            if(watched.length === 0) { alert("No watched videos to clear."); return; }
            
            if(!confirm(`Archive ${watched.length} watched videos to history?`)) return;

            const btn = document.querySelector('#table-toolbar button[title="Archive watched videos to history"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = `<span class="material-symbols-rounded text-base animate-spin">refresh</span> Clearing...`;

            try {
                const user = window.auth ? window.auth.currentUser : null;
                
                for (const v of watched) {
                    // Archive to History (Ghost Record)
                    if(user && window.recordWatchedVideo) {
                        await window.recordWatchedVideo(user.uid, v);
                    }
                    
                    // Remove from Cloud Playlist
                    if (window.currentPlaylistId && window.firestoreDeleteVideo) {
                        await window.firestoreDeleteVideo(window.currentPlaylistId, v.youtube_id);
                    }
                }
                
                // Update Local State
                playlist = playlist.filter(v => !v.watched);
                
                if (!window.currentPlaylistId) savePlaylist();
                renderTable();
                
                // Update History Set locally for immediate effect
                if(window.watchedHistory) {
                    watched.forEach(v => window.watchedHistory.add(v.youtube_id));
                }

            } catch (e) {
                console.error("Clear Watched Failed:", e);
                alert("Error clearing watched videos");
            } finally {
                btn.innerHTML = originalText;
            }
        }

        function savePlaylist() {
            // Updated Key to 'v3' to reset structure safely
            localStorage.setItem('my_playlist_v3', JSON.stringify(playlist));
        }

        // --- PLAYER LOGIC ---
        // Removed selectRow as it is now handled by handleRowClick and renderTable

        function loadVideoByIndex(index) {
            if (index < 0 || index >= playlist.length) return;
            currentIndex = index;
            // Update selection to match playing if reasonable, but don't clear multi-select necessarily
            // For now, let's keep playing distinct from selection, but usually it syncs.
            // Let's sync single selection to playing for simplicity
            selectedIndices.clear();
            selectedIndices.add(index);
            lastSelectedIndex = index;

            const item = playlist[index];
            activeVideoId = item.youtube_id;
            
            document.getElementById('footer-title').textContent = item.title;
            document.getElementById('study-title').textContent = item.title;
            renderTable();

            const savedNote = localStorage.getItem('note_' + activeVideoId) || '';
            document.getElementById('notes-area').value = savedNote;

            if(player && player.loadVideoById) player.loadVideoById(activeVideoId);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                deleteSelected();
            }
        });

        function playNext() { loadVideoByIndex(currentIndex + 1); }
        function playPrev() { loadVideoByIndex(currentIndex - 1); }
        function togglePlay() { if(player) player.getPlayerState() === 1 ? player.pauseVideo() : player.playVideo(); }
        function setVolume(val) { if(player) player.setVolume(val); }
        function updatePlayIcon(isPlaying) { document.getElementById('play-icon').textContent = isPlaying ? 'pause' : 'play_arrow'; }
        
        function setMode(mode) {
            const app = document.getElementById('app-container');
            const vidStage = document.getElementById('video-stage');
            const btnJuke = document.getElementById('btn-jukebox');
            const btnStudy = document.getElementById('btn-study');

            if (mode === 'study') {
                app.classList.remove('mode-jukebox');
                app.classList.add('mode-study');
                document.body.classList.add('mode-study');
                vidStage.style.display = 'block'; 
                btnStudy.classList.replace('text-text-sub', 'text-white');
                btnStudy.classList.add('bg-primary', 'shadow');
                btnJuke.classList.remove('bg-primary', 'shadow', 'text-white');
                btnJuke.classList.add('text-text-sub');

                // Restore Width Preference or Default
                const savedWidth = localStorage.getItem('layout_sidebar_width');
                if (savedWidth) {
                    document.getElementById('left-panel').style.width = savedWidth + 'px';
                } else {
                    document.getElementById('left-panel').style.width = '350px';
                }

            } else {
                app.classList.remove('mode-study');
                app.classList.add('mode-jukebox');
                document.body.classList.remove('mode-study');
                vidStage.style.display = 'none';
                btnJuke.classList.replace('text-text-sub', 'text-white');
                btnJuke.classList.add('bg-primary', 'shadow');
                btnStudy.classList.remove('bg-primary', 'shadow', 'text-white');
                btnStudy.classList.add('text-text-sub');
                document.getElementById('left-panel').style.width = '100%'; 
                
                // Re-render table to ensure data (like Notes icons) is fresh from LS
                renderTable(); 
            }

        }

        const notesArea = document.getElementById('notes-area');
        notesArea.addEventListener('input', () => { if(activeVideoId) localStorage.setItem('note_' + activeVideoId, notesArea.value); });
        function insertTimestamp() {
            if(!player || !activeVideoId) return;
            const time = Math.floor(player.getCurrentTime());
            const min = Math.floor(time / 60);
            const sec = time % 60;
            const stamp = `[${min}:${sec < 10 ? '0'+sec : sec}]`;
            notesArea.value += `\n${stamp} `;
            localStorage.setItem('note_' + activeVideoId, notesArea.value);
        }

        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('yt-player', {
                height: '100%', width: '100%', videoId: '',
                playerVars: { 'playsinline': 1, 'autoplay': 1 },
                events: { 'onReady': (e) => e.target.setVolume(80), 'onStateChange': (e) => {
                    if (e.data == YT.PlayerState.PLAYING) updatePlayIcon(true);
                    else updatePlayIcon(false);
                    if (e.data == YT.PlayerState.ENDED) playNext();
                }}
            });
        }

        // --- RESIZABLE LAYOUTS ---
        function makeResizable() {
            const leftPanel = document.getElementById('left-panel');
            const videoStage = document.getElementById('video-stage');
            const vSplitter = document.getElementById('splitter-vertical');
            const hSplitter = document.getElementById('splitter-horizontal');
            const shield = document.getElementById('iframe-shield');

            // 16:9 Aspect Ratio Constant
            const RATIO = 16 / 9;

            // Helper: Activate Shield
            function startDrag() {
                if (shield) shield.style.display = 'block';
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none';
            }

            // Helper: Deactivate Shield
            function stopDrag() {
                if (shield) shield.style.display = 'none';
                document.body.style.userSelect = 'auto';
                document.body.style.pointerEvents = 'auto';
                document.body.style.cursor = 'default';
            }

            // --- Vertical Resize (Sidebar) ---
            if (vSplitter) {
                vSplitter.onmousedown = function(e) {
                    e.preventDefault();
                    startDrag();
                    document.body.style.cursor = 'col-resize';
                    
                    function onMouseMove(moveEvent) {
                        // 1. Calculate new Sidebar Width
                        let newSidebarWidth = moveEvent.clientX;
                        
                        // Safety: Minimum 250px
                        if (newSidebarWidth < 250) newSidebarWidth = 250;
                        
                        // Safety: Maximum (Leave at least 150px for the video)
                        if (newSidebarWidth > window.innerWidth - 150) {
                            newSidebarWidth = window.innerWidth - 150;
                        }
                        
                        // 2. Apply Sidebar Width
                        leftPanel.style.width = newSidebarWidth + 'px';
                        localStorage.setItem('layout_sidebar_width', newSidebarWidth);

                        // 3. AUTO-ADJUST HEIGHT (Aspect Ratio Sync)
                        // Player Width = Total Window - Sidebar Width
                        const playerWidth = window.innerWidth - newSidebarWidth;
                        
                        // Aspect Ratio 16:9
                        const targetHeight = playerWidth / (16/9);
                        videoStage.style.height = targetHeight + 'px';
                    }
                    
                    function onMouseUp() {
                        stopDrag();
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    }
                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                };
            }

            // --- Horizontal Resize (Video Height) ---
            // Action: User changes Height -> We auto-adjust Width (Sidebar)
            if (hSplitter) {
                hSplitter.onmousedown = function(e) {
                    e.preventDefault();
                    startDrag();
                    document.body.style.cursor = 'row-resize';
                    
                    const startY = e.clientY;
                    // Get the top offset of the video to calculate accurate height
                    const topOffset = videoStage.getBoundingClientRect().top;

                    function onMouseMove(moveEvent) {
                        // 1. Calculate new Video Height
                        let newHeight = moveEvent.clientY - topOffset;
                        if (newHeight < 50) newHeight = 50; // Safety min

                        // 2. Apply Video Height
                        videoStage.style.height = newHeight + 'px';

                        // 3. AUTO-ADJUST WIDTH (Sidebar)
                        // Target Player Width = Height * (16/9)
                        const targetPlayerWidth = newHeight * RATIO;
                        
                        // Sidebar Width = Total Window - Target Player Width
                        let newSidebarWidth = window.innerWidth - targetPlayerWidth;
                        
                        // Safety check: Don't let sidebar disappear completely
                        if (newSidebarWidth < 0) newSidebarWidth = 0;

                        leftPanel.style.width = newSidebarWidth + 'px';
                        localStorage.setItem('layout_sidebar_width', newSidebarWidth);
                    }

                    function onMouseUp() {
                        stopDrag();
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    }
                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                };
            }
        }

        makeResizable();
        renderHeaders(); // Init Headers
        renderTable(); // Init Table
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powerlist</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: { "primary": "#137fec", "bg-dark": "#101922", "surface": "#192633", "border": "#233648", "text-sub": "#92adc9" },
                    fontFamily: { sans: ["Inter", "sans-serif"] }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #111a22; }
        ::-webkit-scrollbar-thumb { background: #233648; border-radius: 4px; }
        
        body { overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        /* Flex Container Safety */
        /* --- LAYOUT & LAYERING --- */
        #left-panel, #player-panel, #video-stage {
            position: relative;
            background-color: #101922 !important; /* Solid background */
            box-sizing: border-box;
        }

        #left-panel { z-index: 10; border-right: 1px solid #233648; }
        #player-panel { z-index: 20; display: flex; flex-direction: column; min-width: 0; }

        /* The Safety Shield (Invisible until dragging) */
        #iframe-shield {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999;
            display: none; /* Hidden by default */
        }

        /* --- SPLITTERS --- */
        #splitter-vertical {
            width: 12px;
            background: #0d1218;
            border-left: 1px solid #233648;
            border-right: 1px solid #233648;
            cursor: col-resize;
            z-index: 50; /* Above everything */
            flex-shrink: 0;
        }
        #splitter-vertical:hover { background: #137fec; }

        #splitter-horizontal {
            height: 12px;
            background: #0d1218;
            border-top: 1px solid #233648;
            border-bottom: 1px solid #233648;
            cursor: row-resize;
            z-index: 50; /* Above everything */
            width: 100%;
            display: block !important; /* Force Visibility */
            flex-shrink: 0;
        }
        #splitter-horizontal:hover { background: #137fec; }

        /* Show based on mode */
        .mode-study #splitter-vertical { display: block; }
        .mode-jukebox #splitter-horizontal { display: block; }

        /* Jukebox Mode */
        .mode-jukebox { flex-direction: column; }
        /* FORCE FLEXBOX LAYOUT */
        #app-container.mode-study {
            display: flex !important;
            flex-direction: row !important;
            width: 100vw !important;
            height: 100vh !important;
            overflow: hidden !important;
        }

        /* SIDEBAR: STRICT LIMITS */
        .mode-study #left-panel {
            width: 350px; /* Default start */
            min-width: 250px !important; /* Minimum safety only */
            /* max-width removed to allow making video smaller */
            flex-shrink: 0 !important;
            border-right: 1px solid #233648;
            z-index: 10;
            position: relative;
            background-color: #101922 !important;
        }

        /* PLAYER: FILL REMAINING SPACE */
        .mode-study #player-panel {
            flex-grow: 1 !important;
            flex-shrink: 1 !important;
            min-width: 0 !important; /* CRITICAL FIX for Flexbox overflow */
            width: auto !important;
            display: flex;
            flex-direction: column;
        }

        /* JUKEBOX OVERRIDES */
        .mode-jukebox #left-panel {
            width: 100% !important;
            flex: 1 !important; /* Take available space */
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allow shrinking */
        }

        .mode-jukebox #player-panel {
            min-height: 80px !important;
            height: 80px !important;
            border-top: 1px solid #233648;
            background: #101922;
            z-index: 50;
            flex-shrink: 0 !important;
            display: flex !important;
        }

        .mode-jukebox .table-container {
            /* Remove fixed calc, let flex handle it */
            /* height: auto !important; REMOVED to restore scroll */
            flex: 1 !important; 
        }

        .mode-jukebox .study-only { display: none !important; }
        .mode-jukebox .jukebox-only { display: flex !important; }
        .mode-jukebox .col-compact-hide { display: table-cell; } /* Show all cols in Jukebox */

        .mode-study .study-only { display: flex !important; }
        .mode-study .jukebox-only { display: none !important; }
        .mode-study .col-compact-hide { display: none; } /* Hide details in Sidebar */

        /* Row States */
        .row-selected { background-color: #233648; } 
        .row-active { background-color: rgba(19, 127, 236, 0.15) !important; border-left: 3px solid #137fec; } 
        
        /* Volume Slider */
        .vol-container:hover .vol-slider { display: block; }
        .vol-slider { display: none; width: 80px; margin-left: 10px; accent-color: #137fec; }

        /* Tags */
        .tag-pill { background: #233648; color: #92adc9; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-right: 4px; display: inline-block; border: 1px solid #233648; white-space: nowrap; }

        /* Modal */
        dialog::backdrop { background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(2px); }
        .input-dark { 
            width: 100%; 
            background: #101922 !important; /* Override Tailwind Forms white bg */
            border: 1px solid #233648; 
            border-radius: 4px; 
            padding: 8px; 
            margin-bottom: 16px; 
            color: white !important; 
            font-size: 14px; 
            outline: none; 
        }
        .input-dark:focus { border-color: #137fec; }
        .input-disabled { background: #192633; color: #92adc9; cursor: not-allowed; }
        
        /* Sorting Indicators */
        th.sortable { cursor: pointer; user-select: none; }
        th.sortable:hover { color: white; }
        th.sort-asc::after { content: ' ▲'; font-size: 0.8em; }
        th.sort-desc::after { content: ' ▼'; font-size: 0.8em; }
        
        /* Drag and Drop */
        tr.opacity-50 {
            opacity: 0.5;
            background-color: rgba(19, 127, 236, 0.2) !important; 
        }
        tr.drag-over {
            border-top: 2px solid #137fec !important; 
        }

        /* Force Solid Backgrounds to stop bleed-through */

        
        /* The "Safety Shield" - Invisible by default */
        #iframe-shield {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999; /* Super high to catch all clicks */
            display: none; /* Hidden normally */
        }
        
        /* Splitters */


        /* Show based on mode */
        .mode-study #splitter-vertical { display: block; }
        .mode-jukebox #splitter-horizontal { display: block; }

        /* --- POWER USER GRID --- */
        #table-toolbar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; background: #192633; border-bottom: 1px solid #233648;
        }
        .table-container { overflow-x: auto; width: 100%; }
        
        /* Grid Borders & Layout */
        table { border-collapse: separate; border-spacing: 0; min-width: 100%; }
        th, td { 
            border-right: 1px solid #233648; 
            border-bottom: 1px solid #233648; /* Row lines too */
            padding: 8px 12px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            vertical-align: middle;
        }
        th:last-child, td:last-child { border-right: none; }
        
        .star-rating { color: #fbbf24; letter-spacing: 2px; }
        
        /* Resizable Header Base */
        .resizable-col { position: relative; }
        
        /* Column Resizer Grip */
        /* Column Resizer Grip */
        .col-resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            background: transparent;
            z-index: 10;
        }
        .col-resizer:hover { background: #137fec; }

        /* --- FIXED WIDTHS (PRP #20) --- */
        /* All columns must have fixed widths to prevent squishing in fixed-layout table */
        .col-index { width: 50px; }
        .col-watched { width: 50px; }
        .col-thumbnail { width: 130px; } /* Increased for safety */
        .col-original_date, .col-published_at { width: 110px; font-family: monospace; }
        .col-rating { width: 140px; } /* Increased for safety */
        .col-duration { width: 70px; text-align: right; font-family: monospace; }
        
        /* Dynamic Columns - Fixed Layout Needs Explicit Widths */
        .col-title { width: 350px; }
        .col-channel { width: 200px; }
        .col-tldr { width: 100px; }
        .col-desc { width: 200px; }
        .col-tags { width: 150px; }
        .col-tags { width: 150px; }
        .col-notes { width: 80px; } /* Increased from 60px and made resizable */

        /* --- TABLE CARD (New Wrapper) --- */
        #table-card {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Jukebox Mode: Card Style */
        .mode-jukebox #table-card {
            margin: 24px 50px;
            border: 1px solid #233648;
            border-radius: 12px;
            background-color: #101922; /* Ensure background behind table */
        }
        
        /* Study Mode: Full Bleed (Sidebar) */
        .mode-study #table-card {
            margin: 0;
            border: none;
            border-radius: 0;
        }
        /* Tag Pills (Interactive) */
        .tag-pill {
            display: inline-flex;
            align-items: center;
            background: #1e2a38;
            color: #8b9bb4;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 12px;
            margin-right: 4px;
            margin-bottom: 2px;
            border: 1px solid #233648;
        }
        .tag-remove {
            margin-left: 5px;
            cursor: pointer;
            color: #ff4d4d;
            font-weight: bold;
        }
        .tag-remove:hover { color: #ff0000; }
        
        .tag-add {
            cursor: pointer;
            color: #137fec;
            font-size: 14px;
            margin-left: 4px;
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
        }
        .tag-add:hover { color: #3b82f6; }
    </style>
</head>
<body class="bg-bg-dark text-white font-sans">

    <header class="h-16 flex items-center justify-between px-6 bg-surface border-b border-border shrink-0 z-20">
        <div class="flex items-center gap-3">
            <div class="size-8 rounded bg-primary/20 text-primary flex items-center justify-center">
                <span class="material-symbols-rounded">play_circle</span>
            </div>
            <h1 class="font-bold text-lg hidden md:block tracking-tight">Powerlist</h1>
        </div>
        <div class="flex bg-bg-dark rounded-lg p-1 border border-border">
            <button onclick="setMode('jukebox')" id="btn-jukebox" class="px-4 py-1.5 rounded-md text-sm font-medium text-white bg-primary shadow">Jukebox</button>
            <button onclick="setMode('study')" id="btn-study" class="px-4 py-1.5 rounded-md text-sm font-medium text-text-sub hover:text-white">Study Mode</button>
        </div>
        <div class="flex items-center gap-3"><div class="size-9 rounded-full bg-surface border border-border"></div></div>
    </header>

    <div id="app-container" class="mode-jukebox flex-1 overflow-hidden">
        <div id="left-panel" class="bg-bg-dark" tabindex="0">
            <div class="jukebox-only p-4 flex justify-between items-center">
                <h2 class="text-xl font-bold">All Videos</h2>
                <button onclick="openAddModal()" class="bg-primary hover:bg-blue-600 px-4 py-2 rounded text-sm font-medium flex items-center gap-2">
                    <span class="material-symbols-rounded text-sm">add</span> Add Video
                </button>
            </div>
            <!-- Table Card Wrapper -->
            <div id="table-card">
                <div id="table-toolbar" class="jukebox-only">
                    <input type="text" id="table-search" placeholder="Search library..." class="bg-bg-dark border border-border rounded px-3 py-1.5 text-sm w-64 focus:border-primary outline-none">
                    <button id="btn-cols" class="text-sm text-text-sub hover:text-white flex items-center gap-1">
                        <span class="material-symbols-rounded text-base">view_column</span> Columns
                    </button>
                </div>
    
                <div class="table-container flex-1 overflow-auto bg-bg-dark">
                    <table class="table-fixed min-w-full text-left border-collapse" style="width: max-content; min-width: 100%;">
                        <thead id="tableHead" class="bg-surface sticky top-0 z-20 text-xs uppercase text-text-sub font-semibold tracking-wider shadow-sm">
                            <!-- Headers generated by JS -->
                        </thead>
                        <tbody id="tableBody" class="divide-y divide-border/50 text-sm text-text-sub"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Vertical Splitter (between Left Panel and Player Panel) -->
        <div id="splitter-vertical" class="splitter"></div>
        <!-- Horizontal Splitter (Moved inside player panel) -->

        <div id="player-panel">


            <div id="video-stage" style="display:none; width: 100%; height: 60%; min-height: 200px; background: black;">
                 <div id="yt-player" style="width: 100%; height: 100%;"></div>
                 <div id="iframe-shield"></div>
            </div>
            
            <div id="splitter-horizontal" class="splitter"></div>

            <div class="study-only p-4 border-b border-border bg-surface flex justify-between items-center">
                <div>
                    <h2 id="study-title" class="text-white font-bold text-lg truncate max-w-md">Select a Video</h2>
                    <div class="text-xs text-text-sub mt-1">Now Playing</div>
                </div>
                <div class="flex gap-2">
                     <button onclick="insertTimestamp()" class="bg-border hover:bg-white/10 text-white px-3 py-1.5 rounded text-xs font-bold flex gap-1 items-center">
                        <span class="material-symbols-rounded text-sm">schedule</span> Timestamp
                     </button>
                </div>
            </div>

            <div class="study-only flex-1 flex flex-col p-6 bg-bg-dark min-h-0">
                <div class="flex flex-col h-full bg-surface rounded-xl border border-border overflow-hidden">
                    <div class="flex items-center justify-between px-4 py-2 border-b border-border bg-[#1e2d3d]">
                        <span class="text-xs font-bold uppercase tracking-wider text-white">My Notes</span>
                        <button onclick="saveNotes()" class="text-xs text-primary hover:text-white">Save</button>
                    </div>
                    <textarea id="notes-area" class="flex-1 w-full bg-transparent p-4 text-gray-200 resize-none outline-none font-mono text-sm leading-relaxed" placeholder="Type notes here..."></textarea>
                </div>
            </div>

            <div class="jukebox-only w-full h-full items-center justify-between px-4 gap-4">
                <!-- Transport Scrubber (PRP #21) -->
                <div id="transport-bar" class="flex items-center gap-3 bg-bg-dark border border-border p-2 rounded-lg flex-1 mr-4">
                    <button id="btn-transport-play" onclick="togglePlay()" class="bg-primary/20 hover:bg-primary text-primary hover:text-white rounded-full p-1 transition-colors">
                        <span class="material-symbols-rounded text-lg">play_arrow</span>
                    </button>
                    
                    <span id="time-current" class="font-mono text-xs text-text-sub w-10 text-right">0:00</span>
                    
                    <input type="range" id="scrubber" min="0" value="0" step="1" 
                           class="flex-1 cursor-pointer accent-primary h-1 bg-border rounded-full appearance-none hover:h-2 transition-all">
                    
                    <span id="time-total" class="font-mono text-xs text-text-sub w-10">0:00</span>
                </div>

                <div class="flex items-center gap-3 w-1/6 min-w-[200px]">
                    <div class="flex flex-col truncate">
                        <span id="footer-title" class="text-white font-bold text-sm truncate">Select a Video</span>
                        <span class="text-xs text-primary">Powerlist Player</span>
                    </div>
                </div>
                
                <div class="flex items-center gap-6 justify-center">
                    <button onclick="playPrev()" class="text-text-sub hover:text-white"><span class="material-symbols-rounded text-2xl">skip_previous</span></button>
                    <button onclick="togglePlay()" class="bg-primary text-white rounded-full p-2 hover:scale-105 shadow-lg shadow-primary/30">
                        <span id="play-icon" class="material-symbols-rounded text-2xl">play_arrow</span>
                    </button>
                    <button onclick="playNext()" class="text-text-sub hover:text-white"><span class="material-symbols-rounded text-2xl">skip_next</span></button>
                </div>

                <div class="w-1/6 flex justify-end items-center vol-container">
                    <span class="material-symbols-rounded text-text-sub">volume_up</span>
                    <input type="range" id="vol-slider" min="0" max="100" value="80" class="vol-slider" oninput="setVolume(this.value)">
                </div>
            </div>
        </div> 
    </div>

    <dialog id="addModal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-96">
        <h3 class="text-lg font-bold mb-4">Add YouTube Video</h3>
        <input type="text" id="newUrl" oninput="debounceFetch()" placeholder="Paste YouTube URL..." class="input-dark text-white placeholder-gray-500">
        <input type="text" id="newTitle" placeholder="Video Title" class="input-dark text-white placeholder-gray-500">
        <input type="text" id="newChannel" placeholder="Channel Name" class="input-dark input-disabled text-white placeholder-gray-500" readonly>
        
        <label class="text-xs text-text-sub uppercase font-bold tracking-wider mb-1 block">Tags (comma separated)</label>
        <input type="text" id="newTags" placeholder="e.g. Jazz, Study, Drum Solo" class="input-dark text-white placeholder-gray-500">

        <div class="flex justify-end gap-2 mt-4">
            <button onclick="closeAddModal()" class="px-4 py-2 text-sm text-text-sub hover:text-white">Cancel</button>
            <button onclick="submitAddVideo()" class="px-4 py-2 bg-primary rounded text-sm font-medium hover:bg-blue-600">Add to List</button>
        </div>
    </dialog>

    <!-- Column Visibility Modal -->
    <dialog id="col-modal" class="bg-surface border border-border rounded-xl p-6 shadow-2xl backdrop:bg-black/80 text-white w-64">
        <h3 class="text-lg font-bold mb-4">Visible Columns</h3>
        <div id="col-list" class="flex flex-col gap-2 max-h-60 overflow-y-auto mb-4">
            <!-- Populated by JS -->
        </div>
        <div class="flex justify-end">
             <button onclick="document.getElementById('col-modal').close()" class="px-4 py-2 bg-primary rounded text-sm hover:bg-blue-600">Done</button>
        </div>
    </dialog>

    <script>
        const INJECTED_DATA = {{ videos_json }};
        // Data Structure Update: Ensure new fields exist
        let playlist = JSON.parse(localStorage.getItem('my_playlist_v3')) || INJECTED_DATA.map(v => ({
            ...v,
            tags: v.tags || [],
            original_date: v.published_at || '', 
            watched: false
        }));

        // --- STATE VARIABLES ---
        let sortState = { col: null, asc: true };
        let selectedIndices = new Set();
        let lastSelectedIndex = -1; 
        let draggedItemIndex = null;
        let activeVideoId = null;
        let currentIndex = -1; 
        let player = null;
        let fetchTimeout = null;
        
        // Search & Filter
        let searchTerm = ""; // New Search State

        // Column Config
        // Key matching the data field or logical ID
        // Initialize Config
        const defaultVisible = {
            index: true, watched: true, thumbnail: true, title: true, tldr: true,
            original_date: true, published_at: true, channel: true, desc: true,
            tags: true, duration: true, rating: true, notes: true
        };
        let visibleColumns = JSON.parse(localStorage.getItem('visible_cols')) || defaultVisible;

        // --- COLUMN CONFIG ---
        const columnsConfig = [
            { key: 'index', label: '#', cls: 'col-index', sortable: false },
            { key: 'watched', label: 'Watched', cls: 'col-watched', sortable: false },
            { key: 'thumbnail', label: 'Thumbnail', cls: 'col-thumbnail', sortable: false },
            { key: 'title', label: 'Title', cls: 'col-title', sortable: true },
            { key: 'tldr', label: 'TL;DR', cls: 'col-tldr', sortable: false },
            { key: 'original_date', label: 'Orig. Date', cls: 'col-original_date', sortable: true },
            { key: 'published_at', label: 'Upload Date', cls: 'col-published_at', sortable: true },
            { key: 'channel', label: 'Channel', cls: 'col-channel', sortable: true },
            { key: 'tags', label: 'Tags', cls: 'col-tags', sortable: false },
            { key: 'rating', label: 'Rating', cls: 'col-rating', sortable: false },
            { key: 'notes', label: 'Notes', cls: 'col-notes', align: 'text-center', sortable: false }
        ];

        // --- RENDER HEADERS ---
        function renderHeaders() {
            const thead = document.getElementById('tableHead');
            thead.innerHTML = '';
            const tr = document.createElement('tr');
            
            // STATIC COLUMNS (No Resizing)
            // STATIC COLUMNS (No Resizing)
            const staticCols = ['index', 'watched', 'thumbnail', 'original_date', 'published_at', 'rating'];

            columnsConfig.forEach(col => {
                if (!visibleColumns[col.key]) return;

                const th = document.createElement('th');
                // Added sticky, top-0, z-20, bg-bg-dark for sticky headers
                let classes = "px-4 py-3 relative sticky top-0 z-20 bg-bg-dark box-border border-b border-border "; 
                
                // Add resizable class only if NOT static
                if (!staticCols.includes(col.key)) {
                    classes += "resizable-col ";
                }

                if (col.cls) classes += col.cls + " "; 
                
                // Priority: Custom Width > Config Width > Auto
                if (customWidths[col.key]) {
                    th.style.width = customWidths[col.key] + 'px';
                    th.style.minWidth = customWidths[col.key] + 'px';
                    th.style.maxWidth = customWidths[col.key] + 'px';
                } else {
                    if (col.width) classes += col.width + " ";
                }
                
                if (col.align) classes += col.align + " ";
                th.className = classes;
                th.id = 'th-' + col.key;

                // 1. Label Container (The ONLY clickable sort target)
                const labelSpan = document.createElement('span');
                labelSpan.className = "flex items-center gap-1 truncate w-full h-full select-none";
                labelSpan.textContent = col.label;

                const isSortable = col.sortable; // Use config property
                
                if (isSortable) {
                    labelSpan.classList.add("cursor-pointer", "hover:text-white");
                    labelSpan.onclick = (e) => {
                        e.stopPropagation(); // Stop bubbling
                        sortPlaylist(col.key);
                    };
                    
                    // Add Sort Indicator
                    if (sortState.col === col.key) {
                        const arrow = document.createElement('span');
                        arrow.className = "text-[10px] ml-1";
                        arrow.textContent = sortState.asc ? '▲' : '▼';
                        labelSpan.appendChild(arrow);
                    }
                }
                
                th.appendChild(labelSpan);

                // 2. Resizer (Sibling to label, does NOT trigger sort)
                // ONLY add resizer if NOT a static column
                if (!staticCols.includes(col.key)) {
                    const resizer = document.createElement('div');
                    resizer.className = 'col-resizer';
                    // Inline styles to ensure hit area is correct and independent
                    resizer.style.position = 'absolute';
                    resizer.style.right = '0';
                    resizer.style.top = '0';
                    resizer.style.bottom = '0';
                    resizer.style.width = '12px'; // Wide hit area
                    resizer.style.cursor = 'col-resize';
                    resizer.style.zIndex = '10';
                    resizer.style.transform = 'translateX(50%)';
                    
                    th.appendChild(resizer);
                }

                tr.appendChild(th);
            });
            thead.appendChild(tr);
            
            makeColumnsResizable();
        }
        let isDraggingScrubber = false;
        
        // Helper: Format Seconds to MM:SS
        function formatTime(seconds) {
            if (!seconds) return "0:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        }

        // Initialize Scrubber Events safely after DOM load
        document.addEventListener('DOMContentLoaded', () => {
            const scrubber = document.getElementById('scrubber');
            if (scrubber) {
                scrubber.oninput = function() {
                    isDraggingScrubber = true;
                    document.getElementById('time-current').textContent = formatTime(this.value);
                };

                scrubber.onchange = function() {
                    isDraggingScrubber = false;
                    if (player && player.seekTo) {
                        player.seekTo(parseFloat(this.value), true);
                    }
                };
            }
        });

        // Update Loop (500ms)
        setInterval(() => {
            if (!player || !player.getCurrentTime) return;
            
            const duration = player.getDuration();
            const current = player.getCurrentTime();

            // Always update Total Time & Scrubber Max
            if (duration) {
                document.getElementById('time-total').textContent = formatTime(duration);
                const scrubber = document.getElementById('scrubber');
                if (scrubber) scrubber.max = duration;
            }

            // Sync Scrubber Position (if not dragging)
            if (!isDraggingScrubber) {
                document.getElementById('time-current').textContent = formatTime(current);
                const scrubber = document.getElementById('scrubber');
                if (scrubber) scrubber.value = current;
                
                // Update Transport Play Button Icon
                const state = player.getPlayerState();
                const btnIcon = document.querySelector('#btn-transport-play span');
                // 1 = Playing, 2 = Paused
                if (btnIcon) btnIcon.textContent = (state === 1) ? 'pause' : 'play_arrow';
            }
        }, 500);

        // Load Custom Widths (Fix for Snap Back)
        let customWidths = JSON.parse(localStorage.getItem('col_widths')) || {};

        // Initialize Events safely after DOM load
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Scrubber Events
            const scrubber = document.getElementById('scrubber');
            if (scrubber) {
                scrubber.oninput = function() {
                    isDraggingScrubber = true;
                    document.getElementById('time-current').textContent = formatTime(this.value);
                };

                scrubber.onchange = function() {
                    isDraggingScrubber = false;
                    if (player && player.seekTo) {
                        player.seekTo(parseFloat(this.value), true);
                    }
                };
            }

            // 2. Column Modal Event
            document.getElementById('btn-cols').addEventListener('click', () => {
                const list = document.getElementById('col-list');
                list.innerHTML = '';
    
                // "Select All" Checkbox
                const allChecked = columnsConfig.every(col => visibleColumns[col.key]);
                
                const selectAllDiv = document.createElement('div');
                selectAllDiv.className = "flex items-center gap-2 p-1.5 hover:bg-white/5 rounded pb-2 mb-2 border-b border-white/10";
                selectAllDiv.innerHTML = `
                    <input type="checkbox" ${allChecked ? 'checked' : ''} onchange="toggleAllColumns(this.checked)" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer">
                    <span class="text-xs text-white uppercase font-bold tracking-wider">Select All</span>
                `;
                list.appendChild(selectAllDiv);
    
                // Individual Columns
                columnsConfig.forEach(col => {
                    const div = document.createElement('div');
                    div.className = "flex items-center gap-2 p-1.5 hover:bg-white/5 rounded";
                    div.innerHTML = `
                        <input type="checkbox" ${visibleColumns[col.key] ? 'checked' : ''} onchange="toggleColumn('${col.key}')" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer">
                        <span class="text-sm text-text-sub">${col.label}</span>
                    `;
                    list.appendChild(div);
                });
                
                document.getElementById('col-modal').showModal();
            });
        });

        function toggleAllColumns(isChecked) {
            columnsConfig.forEach(col => {
                visibleColumns[col.key] = isChecked;
            });
            localStorage.setItem('visible_cols', JSON.stringify(visibleColumns));
            
            // Re-render modal to show updated state immediately (optional, or just close)
            // Ideally we re-populate the list, but for now let's just re-render grid
            renderHeaders();
            renderTable();
            
            // Close and re-open to refresh checkboxes? Or simpler: manually update DOM
            // Let's just re-trigger the modal render logic if it's open
            const modal = document.getElementById('col-modal');
            if (modal.open) {
                document.getElementById('btn-cols').click(); // fast re-render hack or extract render function
                modal.showModal(); // ensure open
            }
        }

        function toggleColumn(key) {
            visibleColumns[key] = !visibleColumns[key];
            localStorage.setItem('visible_cols', JSON.stringify(visibleColumns));
            renderHeaders();
            renderTable();
            
            // Check Select All state
            const allChecked = columnsConfig.every(col => visibleColumns[col.key]);
            const selectAllBox = document.querySelector('#col-list input[onchange^="toggleAllColumns"]');
            if(selectAllBox) selectAllBox.checked = allChecked;
        }

        // --- RENDER TABLE ---
        function renderTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            // 1. Filter
            let filteredPlaylist = playlist.map((item, index) => ({ item, originalIndex: index }));
            
            if (searchTerm) {
                filteredPlaylist = filteredPlaylist.filter(wrapper => {
                    const i = wrapper.item;
                    const text = (i.title + ' ' + i.channel + ' ' + (i.tags||[]).join(' ')).toLowerCase();
                    return text.includes(searchTerm);
                });
            }

            // 2. Render Rows
            filteredPlaylist.forEach(({ item, originalIndex }) => {
                const vidId = item.youtube_id;
                const isActive = (vidId === activeVideoId);
                const isSelected = selectedIndices.has(originalIndex);

                const tr = document.createElement('tr');
                let classes = "group transition-colors cursor-pointer select-none "; 
                if (isActive) classes += "row-active bg-surface "; 
                else if (isSelected) classes += "row-selected ";
                else classes += "hover:bg-surface ";
                
                tr.className = classes;
                
                // Events (Use originalIndex for logic)
                tr.setAttribute('draggable', 'true');
                tr.ondragstart = (e) => handleDragStart(e, originalIndex);
                tr.ondragend = (e) => handleDragEnd(e);
                tr.ondragover = (e) => handleDragOver(e, originalIndex);
                tr.ondragleave = (e) => handleDragLeave(e, originalIndex);
                tr.ondrop = (e) => handleDrop(e, originalIndex);
                tr.onclick = (e) => handleRowClick(e, originalIndex);
                tr.ondblclick = () => loadVideoByIndex(originalIndex);

                // Data Prep
                const thumbnail = item.thumbnail_url || `https://img.youtube.com/vi/${vidId}/default.jpg`;
                const tldr = item.tldr || "-"; 
                const desc = "-"; 
                const rating = "☆☆☆☆☆";
                const tags = item.tags || [];

                // Dynamic Column Rendering
                let html = '';
                
                if (visibleColumns.index) html += `<td class="text-center text-text-sub font-mono text-xs col-index">${isActive ? '<span class="material-symbols-rounded text-primary animate-pulse text-base">equalizer</span>' : (originalIndex + 1)}</td>`;
                
                if (visibleColumns.watched) html += `<td class="text-center col-watched"><input type="checkbox" ${item.watched ? 'checked' : ''} onclick="toggleWatched(event, ${originalIndex})" class="rounded bg-bg-dark border-border text-primary focus:ring-0 cursor-pointer"></td>`;
                
                if (visibleColumns.thumbnail) html += `<td class="text-center p-1 col-thumbnail"><img src="${thumbnail}" style="height: 30px; border-radius: 2px; margin: auto;"></td>`;
                
                if (visibleColumns.title) html += `<td class="font-medium text-white col-title" title="${item.title}">${item.title}</td>`;
                
                if (visibleColumns.tldr) html += `<td class="text-xs text-text-sub col-tldr">${tldr}</td>`;
                
                if (visibleColumns.original_date) html += `<td class="text-xs font-mono text-text-sub col-original_date">${item.original_date || '-'}</td>`;
                
                if (visibleColumns.published_at) html += `<td class="text-xs font-mono text-text-sub col-published_at">${item.published_at || '-'}</td>`;
                
                if (visibleColumns.channel) html += `<td class="text-sm text-text-sub col-channel">${item.channel || ''}</td>`;
                
                if (visibleColumns.tags) {
                     const tagHtml = tags.map(t => `<span class="tag-pill">${t} <span class="tag-remove" onclick="removeTag(${originalIndex}, '${t}')">×</span></span>`).join('');
                     html += `<td class="col-tags">${tagHtml} <span class="tag-add" onclick="addNewTag(${originalIndex})">+</span></td>`;
                }
                
                if (visibleColumns.rating) html += `<td class="text-center star-rating text-lg leading-none pb-1 col-rating">${rating}</td>`;
                
                if (visibleColumns.notes) html += `<td class="text-center col-notes">${localStorage.getItem('note_' + vidId) ? '<span class="material-symbols-rounded text-xs text-primary">description</span>' : ''}</td>`;

                tr.innerHTML = html;
                tbody.appendChild(tr);
            });
        }

        // --- SORTING LOGIC ---
        function sortPlaylist(key) {
            // Toggle sort state
            if (sortState.col === key) {
                sortState.asc = !sortState.asc;
            } else {
                sortState.col = key;
                sortState.asc = true;
            }

            // Sort logic
            playlist.sort((a, b) => {
                let valA = a[key] || '';
                let valB = b[key] || '';
                
                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();
                
                if (valA < valB) return sortState.asc ? -1 : 1;
                if (valA > valB) return sortState.asc ? 1 : -1;
                return 0;
            });
            
            // Re-render
            renderHeaders(); 
            renderTable();
        }

        // --- ROW SELECTION ---
        function handleRowClick(e, index) {
            if (e.shiftKey && lastSelectedIndex !== -1) {
                const start = Math.min(lastSelectedIndex, index);
                const end = Math.max(lastSelectedIndex, index);
                selectedIndices.clear();
                for (let i = start; i <= end; i++) selectedIndices.add(i);
            } else if (e.metaKey || e.ctrlKey) {
                if (selectedIndices.has(index)) selectedIndices.delete(index);
                else selectedIndices.add(index);
                lastSelectedIndex = index;
            } else {
                selectedIndices.clear();
                selectedIndices.add(index);
                lastSelectedIndex = index;
            }
            renderTable();
        }

        // --- DRAG & DROP ---
        function handleDragStart(e, index) {
            draggedItemIndex = index;
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('opacity-50');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('opacity-50');
            document.querySelectorAll('tr').forEach(el => el.classList.remove('drag-over'));
        }

        function handleDragOver(e, index) {
            e.preventDefault(); 
            if (index === draggedItemIndex) return;
            e.currentTarget.classList.add('drag-over');
        }
        
        function handleDragLeave(e, index) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e, index) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (draggedItemIndex === null || draggedItemIndex === index) return;
            
            const item = playlist.splice(draggedItemIndex, 1)[0];
            playlist.splice(index, 0, item);
            
            draggedItemIndex = null;
            savePlaylist();
            renderTable();
        }

        // --- DRAG TO RESIZE COLUMNS (FIXED: STRICT DIRECTIONALITY V3) ---
        function makeColumnsResizable() {
            const table = document.querySelector('table');
            
            // Critical: Enable fixed layout
            table.style.tableLayout = 'fixed'; 
            table.style.boxSizing = 'border-box';

            document.querySelectorAll('.col-resizer').forEach(resizer => {
                // Double protection against sort
                resizer.onclick = (e) => e.stopPropagation();

                resizer.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation(); 
                    
                    const th = resizer.parentElement;
                    const colKey = th.id.replace('th-', ''); 
                    
                    const startX = e.pageX; 
                    const startWidth = th.offsetWidth;
                    // measure exact current pixel width to avoid "jumping"
                    const startTableWidth = table.getBoundingClientRect().width; 
                    
                    // 1. FREEZE TABLE PIXELS 
                    // (prevent auto-stretch behavior during resize)
                    table.style.width = startTableWidth + 'px';
                    table.style.minWidth = startTableWidth + 'px';
                    table.style.maxWidth = 'none';

                    function onMouseMove(moveEvent) {
                        moveEvent.preventDefault();
                        
                        const currentX = moveEvent.pageX;
                        const delta = currentX - startX;
                        
                        // 2. CALCULATE NEW WIDTHS
                        const newColWidth = Math.max(40, startWidth + delta);
                        const effectiveDelta = newColWidth - startWidth; // Actual change after min-width check
                        
                        // 3. APPLY (Target + Table ONLY)
                        // By changing the table width by exactly the same amount as the column,
                        // we insure the "slack" is taken up by the table's total size,
                        // preventing any other columns from shifting.
                        th.style.width = newColWidth + 'px';
                        th.style.minWidth = newColWidth + 'px';
                        th.style.maxWidth = newColWidth + 'px';

                        table.style.width = (startTableWidth + effectiveDelta) + 'px';
                        table.style.minWidth = (startTableWidth + effectiveDelta) + 'px';
                    }

                    function onMouseUp(e) {
                         window.removeEventListener('mousemove', onMouseMove);
                         window.removeEventListener('mouseup', onMouseUp);
                        
                         // Save preference
                         if (colKey) {
                             const finalW = parseFloat(th.style.width);
                             customWidths[colKey] = finalW;
                             localStorage.setItem('col_widths', JSON.stringify(customWidths));
                         }
                    }

                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                });
                
                resizer.addEventListener('click', e => e.stopPropagation());
            });
        }

        // --- TAG MANAGEMENT ---
        function removeTag(index, tagText) {
            const vid = playlist[index];
            if (!vid.tags) return;
            vid.tags = vid.tags.filter(t => t !== tagText);
            savePlaylist();
            renderTable();
        }

        function addNewTag(index) {
            const newTag = prompt("Enter new tag:");
            if (newTag && newTag.trim() !== "") {
                if (!playlist[index].tags) playlist[index].tags = [];
                playlist[index].tags.push(newTag.trim());
                savePlaylist();
                renderTable();
            }
        }

        // --- NEW LOGIC: WATCHED TOGGLE ---
        function toggleWatched(e, index) {
            e.stopPropagation(); // Stop click from selecting row
            playlist[index].watched = !playlist[index].watched;
            savePlaylist();
        }

        // --- FETCH METADATA ---
        function debounceFetch() { clearTimeout(fetchTimeout); fetchTimeout = setTimeout(fetchMetadata, 500); }

        async function fetchMetadata() {
            const url = document.getElementById('newUrl').value;
            if (url.length < 10) return;
            document.getElementById('newTitle').placeholder = "Fetching...";
            
            try {
                const res = await fetch(`https://noembed.com/embed?url=${url}`);
                const data = await res.json();
                if (data.title) {
                    document.getElementById('newTitle').value = data.title;
                    document.getElementById('newChannel').value = data.author_name;
                }
            } catch (e) { console.error(e); }
        }

        // --- PLAYLIST MANAGEMENT ---
        const modal = document.getElementById('addModal');
        function openAddModal() { modal.showModal(); }
        function closeAddModal() { modal.close(); }

        const GEMINI_API_KEY = "{{ gemini_api_key }}";

        async function enrichVideo(title, description) {
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "None") {
                console.warn("No Gemini API Key found. Skipping enrichment.");
                return {};
            }

            const prompt = `
            You are a Metadata Librarian.
            Title: ${title}
            Description: ${description || "No description provided."}

            Return ONLY valid JSON:
            {
              "tldr": "A 15-word max engaging summary.",
              "original_date": "YYYY-MM-DD" (or null if unknown),
              "tags": ["tag1", "tag2", "tag3", "tag4"] (Max 5 lowercase tags)
            }
            `;

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Clean markdown
                const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
                return JSON.parse(cleanText);

            } catch (e) {
                console.error("Enrichment failed:", e);
                return {};
            }
        }

        async function submitAddVideo() {
            const url = document.getElementById('newUrl').value;
            if (!url) return;

            // Extract ID
            let vidId = '';
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            if (match && match[2].length === 11) {
                vidId = match[2];
            } else {
                alert("Invalid YouTube URL");
                return;
            }

            const btn = document.querySelector('#addModal button.bg-primary');
            const originalBtnText = btn.textContent;
            btn.textContent = "Analyzing...";
            btn.disabled = true;

            try {
                // 1. Basic Metadata (Noembed)
                // Use a CORS proxy if needed, or helper. For now direct Noembed usually has CORS headers.
                const noembedUrl = `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${vidId}`;
                
                const res = await fetch(noembedUrl);
                const data = await res.json();
                
                const title = data.title || (document.getElementById('newTitle').value || "Unknown Title");
                const author = data.author_name || (document.getElementById('newChannel').value || "Unknown Channel");
                const thumb = `https://img.youtube.com/vi/${vidId}/hqdefault.jpg`;

                // 2. AI Enrichment
                console.log("Enriching video...");
                const enrichment = await enrichVideo(title, ""); 
                
                const newVideo = {
                    youtube_id: vidId,
                    title: title,
                    channel: author,
                    thumbnail_url: thumb,
                    duration: "VOD", 
                    published_at: new Date().toISOString().split('T')[0],
                    watched: false,
                    tldr: enrichment.tldr || "-",
                    original_date: enrichment.original_date || new Date().toISOString().split('T')[0],
                    tags: enrichment.tags || [],
                    rating: 0
                };

                playlist.unshift(newVideo);
                savePlaylist();
                renderTable();
                closeAddModal();
                
                // Clear inputs
                document.getElementById('newUrl').value = '';
                document.getElementById('newTitle').value = '';
                document.getElementById('newChannel').value = '';
                document.getElementById('newTags').value = '';

            } catch (e) {
                console.error(e);
                alert("Error adding video: " + e.message);
            } finally {
                btn.textContent = originalBtnText;
                btn.disabled = false;
            }
        }

        function deleteSelected() {
            if (selectedIndices.size === 0) return;
            if (confirm(`Delete ${selectedIndices.size} selected video(s)?`)) {
                // Delete in reverse order to maintain indices logic during splice
                const indices = Array.from(selectedIndices).sort((a, b) => b - a);
                indices.forEach(idx => playlist.splice(idx, 1));
                
                selectedIndices.clear();
                lastSelectedIndex = -1;
                savePlaylist();
                renderTable();
            }
        }

        function savePlaylist() {
            // Updated Key to 'v3' to reset structure safely
            localStorage.setItem('my_playlist_v3', JSON.stringify(playlist));
        }

        // --- PLAYER LOGIC ---
        // Removed selectRow as it is now handled by handleRowClick and renderTable

        function loadVideoByIndex(index) {
            if (index < 0 || index >= playlist.length) return;
            currentIndex = index;
            // Update selection to match playing if reasonable, but don't clear multi-select necessarily
            // For now, let's keep playing distinct from selection, but usually it syncs.
            // Let's sync single selection to playing for simplicity
            selectedIndices.clear();
            selectedIndices.add(index);
            lastSelectedIndex = index;

            const item = playlist[index];
            activeVideoId = item.youtube_id;
            
            document.getElementById('footer-title').textContent = item.title;
            document.getElementById('study-title').textContent = item.title;
            renderTable();

            const savedNote = localStorage.getItem('note_' + activeVideoId) || '';
            document.getElementById('notes-area').value = savedNote;

            if(player && player.loadVideoById) player.loadVideoById(activeVideoId);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                deleteSelected();
            }
        });

        function playNext() { loadVideoByIndex(currentIndex + 1); }
        function playPrev() { loadVideoByIndex(currentIndex - 1); }
        function togglePlay() { if(player) player.getPlayerState() === 1 ? player.pauseVideo() : player.playVideo(); }
        function setVolume(val) { if(player) player.setVolume(val); }
        function updatePlayIcon(isPlaying) { document.getElementById('play-icon').textContent = isPlaying ? 'pause' : 'play_arrow'; }
        
        function setMode(mode) {
            const app = document.getElementById('app-container');
            const vidStage = document.getElementById('video-stage');
            const btnJuke = document.getElementById('btn-jukebox');
            const btnStudy = document.getElementById('btn-study');

            if (mode === 'study') {
                app.className = 'mode-study';
                document.body.classList.add('mode-study');
                vidStage.style.display = 'block'; 
                btnStudy.classList.replace('text-text-sub', 'text-white');
                btnStudy.classList.add('bg-primary', 'shadow');
                btnJuke.classList.remove('bg-primary', 'shadow', 'text-white');
                btnJuke.classList.add('text-text-sub');

                // Restore Width Preference or Default
                const savedWidth = localStorage.getItem('layout_sidebar_width');
                if (savedWidth) {
                    document.getElementById('left-panel').style.width = savedWidth + 'px';
                } else {
                    document.getElementById('left-panel').style.width = '350px';
                }

            } else {
                app.className = 'mode-jukebox';
                document.body.classList.remove('mode-study');
                vidStage.style.display = 'none';
                btnJuke.classList.replace('text-text-sub', 'text-white');
                btnJuke.classList.add('bg-primary', 'shadow');
                btnStudy.classList.remove('bg-primary', 'shadow', 'text-white');
                btnStudy.classList.add('text-text-sub');

                // Clear Inline Styles to let CSS take over (REMOVE PROPERTY)
                document.getElementById('left-panel').style.removeProperty('width');
                document.getElementById('player-panel').style.removeProperty('height');
            }
        }

        const notesArea = document.getElementById('notes-area');
        notesArea.addEventListener('input', () => { if(activeVideoId) localStorage.setItem('note_' + activeVideoId, notesArea.value); });
        function insertTimestamp() {
            if(!player || !activeVideoId) return;
            const time = Math.floor(player.getCurrentTime());
            const min = Math.floor(time / 60);
            const sec = time % 60;
            const stamp = `[${min}:${sec < 10 ? '0'+sec : sec}]`;
            notesArea.value += `\n${stamp} `;
            localStorage.setItem('note_' + activeVideoId, notesArea.value);
        }

        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('yt-player', {
                height: '100%', width: '100%', videoId: '',
                playerVars: { 'playsinline': 1, 'autoplay': 1 },
                events: { 'onReady': (e) => e.target.setVolume(80), 'onStateChange': (e) => {
                    if (e.data == YT.PlayerState.PLAYING) updatePlayIcon(true);
                    else updatePlayIcon(false);
                    if (e.data == YT.PlayerState.ENDED) playNext();
                }}
            });
        }

        // --- RESIZABLE LAYOUTS ---
        function makeResizable() {
            const leftPanel = document.getElementById('left-panel');
            const videoStage = document.getElementById('video-stage');
            const vSplitter = document.getElementById('splitter-vertical');
            const hSplitter = document.getElementById('splitter-horizontal');
            const shield = document.getElementById('iframe-shield');

            // 16:9 Aspect Ratio Constant
            const RATIO = 16 / 9;

            // Helper: Activate Shield
            function startDrag() {
                if (shield) shield.style.display = 'block';
                document.body.style.userSelect = 'none';
                document.body.style.pointerEvents = 'none';
            }

            // Helper: Deactivate Shield
            function stopDrag() {
                if (shield) shield.style.display = 'none';
                document.body.style.userSelect = 'auto';
                document.body.style.pointerEvents = 'auto';
                document.body.style.cursor = 'default';
            }

            // --- Vertical Resize (Sidebar) ---
            if (vSplitter) {
                vSplitter.onmousedown = function(e) {
                    e.preventDefault();
                    startDrag();
                    document.body.style.cursor = 'col-resize';
                    
                    function onMouseMove(moveEvent) {
                        // 1. Calculate new Sidebar Width
                        let newSidebarWidth = moveEvent.clientX;
                        
                        // Safety: Minimum 250px
                        if (newSidebarWidth < 250) newSidebarWidth = 250;
                        
                        // Safety: Maximum (Leave at least 150px for the video)
                        if (newSidebarWidth > window.innerWidth - 150) {
                            newSidebarWidth = window.innerWidth - 150;
                        }
                        
                        // 2. Apply Sidebar Width
                        leftPanel.style.width = newSidebarWidth + 'px';
                        localStorage.setItem('layout_sidebar_width', newSidebarWidth);

                        // 3. AUTO-ADJUST HEIGHT (Aspect Ratio Sync)
                        // Player Width = Total Window - Sidebar Width
                        const playerWidth = window.innerWidth - newSidebarWidth;
                        
                        // Aspect Ratio 16:9
                        const targetHeight = playerWidth / (16/9);
                        videoStage.style.height = targetHeight + 'px';
                    }
                    
                    function onMouseUp() {
                        stopDrag();
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    }
                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                };
            }

            // --- Horizontal Resize (Video Height) ---
            // Action: User changes Height -> We auto-adjust Width (Sidebar)
            if (hSplitter) {
                hSplitter.onmousedown = function(e) {
                    e.preventDefault();
                    startDrag();
                    document.body.style.cursor = 'row-resize';
                    
                    const startY = e.clientY;
                    // Get the top offset of the video to calculate accurate height
                    const topOffset = videoStage.getBoundingClientRect().top;

                    function onMouseMove(moveEvent) {
                        // 1. Calculate new Video Height
                        let newHeight = moveEvent.clientY - topOffset;
                        if (newHeight < 50) newHeight = 50; // Safety min

                        // 2. Apply Video Height
                        videoStage.style.height = newHeight + 'px';

                        // 3. AUTO-ADJUST WIDTH (Sidebar)
                        // Target Player Width = Height * (16/9)
                        const targetPlayerWidth = newHeight * RATIO;
                        
                        // Sidebar Width = Total Window - Target Player Width
                        let newSidebarWidth = window.innerWidth - targetPlayerWidth;
                        
                        // Safety check: Don't let sidebar disappear completely
                        if (newSidebarWidth < 0) newSidebarWidth = 0;

                        leftPanel.style.width = newSidebarWidth + 'px';
                        localStorage.setItem('layout_sidebar_width', newSidebarWidth);
                    }

                    function onMouseUp() {
                        stopDrag();
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    }
                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                };
            }
        }

        makeResizable();
        renderHeaders(); // Init Headers
        renderTable(); // Init Table
    </script>
</body>
</html>
